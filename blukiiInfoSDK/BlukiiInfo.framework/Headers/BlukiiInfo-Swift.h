// Generated by Apple Swift version 3.0 (swiftlang-800.0.46.2 clang-800.0.38)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import Foundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSCoder;

/**
  Read only data set for 3D axis data
*/
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
/**
  The x-Axis value

  returns:
  x-axis value. Int16.min if not set.
*/
@property (nonatomic, readonly) int16_t x;
/**
  The y-Axis value

  returns:
  y-axis value. Int16.min if not set.
*/
@property (nonatomic, readonly) int16_t y;
/**
  The z-Axis value

  returns:
  z-axis value. Int16.min if not set.
*/
@property (nonatomic, readonly) int16_t z;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
@end


/**
  Read only data object for sensor data that is emitted by blukii beacons
  BeaconSensor values are part of \code
  BKDiscoveryData
  \endcode
  seealso:
  \code
  BKDiscoveryData
  \endcode
*/
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
/**
  The value of the air pressure sensor. (Read-Only)
  If the beacon does not emit air pressure the default value is Int16.min

  returns:
  Air pressure in hP
*/
@property (nonatomic, readonly) int16_t airPressure;
/**
  The value of the light sensor. (Read-Only)
  If the beacon does not emit light the default value is Int16.min

  returns:
  Light in Lux
*/
@property (nonatomic, readonly) int16_t light;
/**
  The value of the humidity sensor. (Read-Only)
  If the beacon does not emit humidity the default value is Int16.min

  returns:
  Humidity in percent (%)
*/
@property (nonatomic, readonly) int16_t humidity;
/**
  The value of the temperature sensor. (Read-Only)
  If the beacon does not emit temperature the default value is Float()

  returns:
  Temperature in degrees Celsius (°C)
*/
@property (nonatomic, readonly) float temperature;
/**
  The 3D axis Valuee of the acceleration sensor.
  <em>Note:</em> If the scan duration longer than one advertising interval duration the maximum value of each axis is returned

  returns:
  AxisData values of acceleration
*/
@property (nonatomic, readonly, strong) BKAxisData * _Nullable acceleration;
/**
  The  3D axis values of magnetism sensor.
  <em>Note:</em> If the scan duration is longer than one advertising interval duration the maximum value of each axis is returned

  returns:
  AxisData values of magnetism
*/
@property (nonatomic, readonly, strong) BKAxisData * _Nullable magnetism;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
@end

@class BKFeatureValidator;
@class BKResolveSettings;
@class BKDiscoverySettings;
@class BKInputElement;

/**
  <h1>Main Controller class for discovering BLE modules and resolving blukii concerned data from the blukii Info Manager.</h1>
  BlukiiClient is a single point of contact for all data retieving actions as follows:
  <ul>
    <li>
      Discovering BLE modules, extracting BLE data and resolving data from blukii Info Manager (https://manager.blukiiinfo.com)
    </li>
    <li>
      Resolving data for a single blukii module or tag from blukii Info Manager
    </li>
    <li>
      Resolving news from blukii Info Manager
    </li>
  </ul>
  <h2>A. Discover BLE modules, extract their BLE data and resolve their data from blukii Info Manager</h2>
  Use this feature to discover BLE modules in your environment and optionally retrieve corresponding data from blukii Info Manager.
  To do this you have to do the following steps:
  <h3>1. Initialize and start discovery</h3>
  Call \code
  initDiscovery()
  \endcode and implement the \code
  BKClientDiscoveryDelegate
  \endcode delegates. After initialization is ready (delegate \code
  onDiscoveryInitialized()
  \endcode) you can start the discovery.
  \code
  var mBlukiiClient: BKClient!

  override func viewDidLoad() {
      ...
      mBlukiiClient = BKClient()
      mBlukiiClient.discoveryDelegate = self
      mBlukiiClient.initDiscovery()
      ...
  }

  func onInitialized() {
      if mBlukiiClient.startDiscovery() {
          // Discovery successfully started
      }
  }

  func onDiscoveryResult(discoveryResultList: [BlukiiInfo.BKOutputElement]) { }
  func onDiscoveryError(errorCode: BlukiiInfo.BKClient.ErrorCode) { }
  func onDiscoveryInfo(infoCode: BlukiiInfo.BKClient.InfoCode) { }

  \endcode<h3>2. Configure discovery settings</h3>
  Use the \code
  BKDiscoverySettings
  \endcode object for configuring discovery. Get \code
  BKClient.discoverySettings
  \endcode to retrieve the settings property set.
  \code
  func onInitialized() {
        // Discovery successfully initialized

        let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
        discoverySettings.setRssiThreshold(-100)
        discoverySettings.scanDuration = 10000
        ...

        if mBlukiiClient.startDiscovery() {
            // Discovery successfully started
        }
   }

  \endcodeWhen BLE scanner is started the BLE discovery is acting according to the \code
  BKDiscoverySettings
  \endcode:
  <ul>
    <li>
      The scanner is searching for BLE modules inside the defined rssi range (\code
      BKDiscoverySettings.getRssiThreshold()
      \endcode).
    </li>
    <li>
      After one scan duration (\code
      BKDiscoverySettings.scanDuration
      \endcode) the results are called back to (\code
      BKClientDiscoveryDelegate.onDiscoveryResult(_: )
      \endcode)
    </li>
    <li>
      This is repeated until BLE Scanning is stopped by \code
      BKClient.stopDiscovery()
      \endcode or the app did enter the background.
    </li>
    <li>
      if the scanner is paused according to the \code
      BKDiscoverySettings
      \endcode the info \code
      BKClient.InfoCode.INFO_DISCOVERY_PAUSED
      \endcode is called.
    </li>
    <li>
      For background scanning it is necessary to be in the iBeacon Region 123456789AB-CDEF-01234-00000000002 or 123456789AB-CDEF-01234-00000000003. In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
    </li>
  </ul>
  <h3>3. Configure resolver settings</h3>
  Use the \code
  BKResolveSettings
  \endcodeobject for configuring the resolving of the blukii Info Manager data.
  Call \code
  BKClient.resolveSettings
  \endcodeto retrieve the settings property set.
  <em>Note:</em> \code
  BKResolveSettings.resolveEnabled
  \endcode has to be set true to enable the resolver!
  \code
  func onInitialized() {
        // Discovery successfully initialized

        let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
        discoverySettings.setRssiThreshold(-100)
        discoverySettings.scanDuration = 10000
        ...
        
        // change resolver settings
        let resolveSettings: BKResolveSettings = mBlukiiClient.resolveSettings
        resolveSettings.resolveEnabled = true
        resolveSettings.setLanguagePriority([BKResolveSettings.OutputLanguage.English, BKResolveSettings.OutputLanguage.German])
        ...

        if mBlukiiClient.startDiscovery() {
            // Discovery successfully started
        }
   }

  \endcode<h3>4. Retrieve results</h3>
  The callback \code
  BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])
  \endcode will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
  <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
  \code
  func onDiscoveryResult(discoveryResultList: [BKOutputElement]) {
    // Discovery phase has finished: list of OutputElements are retrieved

    for outputElement in discoveryResultList {
       let id = outputElement.id
       let rssi = outputElement.discoveryData?.rssi
       ...
    }
  }

  \endcode<h3>5. Retrieve errors and infos</h3>
  The callbacks \code
  BKClientDiscoveryDelegate.onDiscoveryError(BKClient.ErrorCode)
  \endcode and \code
  BKClientDiscoveryDelegate.onDiscoveryInfo(BKClient.InfoCode)
  \endcode will be called if there is important information about the discover process.
  \code
  func onDiscoveryError(errorCode: BKClient.ErrorCode) {
      // An error has been sent from discover
  }

  func onDiscoveryInfo(infoCode: BKClient.InfoCode) {
      // An info has been sent from discovery
  }

  \endcode<h2>B. Resolve data for a single blukii module or tag from blukii Info Manager</h2>
  Retrieve data for a module or tag from blukii Info Manager by calling \code
  resolveInputElement(InputElement)
  \endcode
  You have to prepare an \code
  BKInputElement
  \endcode that stands for a blukii number, NFC tag or scan result. Please see \code
  BKInputElement
  \endcode for more Information.
  If the resolving proccess is successfull the delegate \code
  BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)
  \endcode is called.
  Otherwise the delegate \code
  BKClientResolveDelegate.onResolveInputElementError(inputElement: BKInputElement, errorCode: BKClient.ErrorCode)
  \endcode lets you know the error of the resolving proccess.
  \code
  mBlukiiClient.resolveDelegate = self

  func resolveSingleElement() {
      // call resolver
      let inputElement = BKInputElement(tagID: "", inputType: BKInputSourceType.NFC)
      mBlukiiClient.resolveInputElement(inputElement)
  }

  func onResolveInputElementResult(outputElement: BKOutputElement) {
      let id = outputElement.id
      let url = outputElement.resolveData?.url
  }

  func onResolveInputElementError(inputElement: BKInputElement, errorCode: BKClient.ErrorCode) {
      // An error has been sent from resolver
  }

  \endcode<h2>C. Resolving news from blukii Info Manager</h2>
  Retrieve a translated news text from the blukii Info Manager.
  If the resolving process is successfull the delegate \code
  BKClientNewsDelegate.onNewsResult(news: String)
  \endcode is called.
  Otherwise the delegate \code
  BKClientNewsDelegate.onNewsError(errorCode: BKClient.ErrorCode)
  \endcode lets you know the error of the resolving process.
  \code
  mBlukiiClient.newsDelegate = self

  func resolveNews() {
      mBlukiiClient.resolveServerNews("en-gb")
  }

  func onNewsResult(news: String) {
      // news retrieved
  }

  func onNewsError(errorCode: BlukiiInfo.BKClient.ErrorCode) {
      // An error has been sent from resolver
  }

  \endcode*/
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/**
  The Helper Object to validate application and mobile device features.
*/
@property (nonatomic, readonly, strong) BKFeatureValidator * _Null_unspecified featureValidator;
/**
  Resolver Settings
*/
@property (nonatomic, readonly, strong) BKResolveSettings * _Null_unspecified resolveSettings;
/**
  Discovery Settings
*/
@property (nonatomic, readonly, strong) BKDiscoverySettings * _Null_unspecified discoverySettings;
/**
  Constructor for initiating a blukii client.
*/
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/**
  Gets the state if BLE scanner is actuallly running.

  returns:
  true, if BLE scanner is scanning
*/
- (BOOL)isDiscovering;
/**
  Initializes the discovery service.
  If successful, the delegate \code
  BKClientDiscoveryDelegate.onDiscoveryInitialized()
  \endcode is called.
  Otherwise the delegate `BKClientDiscoveryDelegate.onDiscoveryError(errorCode: BKClient.ErrorCode) is called with an error.
  <em>Note</em>: By calling this function the service instance BKDeviceDiscoveryService is started and binded by the BKClient object. This is required before calling \code
  startDiscovery()
  \endcode and \code
  stopDiscovery()
  \endcode for starting and stopping the discovery for BLE modules. Without \code
  startDiscovery()
  \endcodeBKDeviceDiscoveryService is not do any action and therefore not using the battery.
  <em>Note</em>: Use this function only, if the view is loaded. For Example viewDidAppear.
*/
- (void)initDiscovery SWIFT_METHOD_FAMILY(none);
/**
  Gets the state if the discovery service is initialized.

  returns:
  true, if discovery service is initialized
*/
- (BOOL)isDiscoveryInitialized;
/**
  Starts the BLE scanner.
  It only can be started if the discovery service has been initialized befor by calling initDiscovery()!
  <em>Background mode</em>: If the app change to the background, the scan will not stop. Conditions:
  <ul>
    <li>
      capabilities -> Background Modes -> Location Update -> enable
    </li>
    <li>
      capabilities -> Background Modes -> Use Bluetooth LE accessoires -> enable
    </li>
    <li>
      info.plist: Enter a value for NSLocationAlwaysUsageDescription
    </li>
    <li>
      \code
      BKDiscoverySettings.scanInBackground
      \endcode -> true
    </li>
  </ul>
  <em>Note</em>: Only when the BLE scanner is started successfully the \code
  BKClientDiscoveryDelegate
  \endcode delegates are called if there is any discovery result, error or info.
  You can stop scanning by calling \code
  stopDiscovery()
  \endcode

  returns:
  true, if start is successful.
*/
- (BOOL)startDiscovery;
/**
  Stops the BLE scanner.
  You can start scanning by calling \code
  startDiscovery()
  \endcode

  returns:
  true, if stop is successful.
*/
- (BOOL)stopDiscovery;
/**
  Starts the resolver to retrieve blukii Info Manager data of one single element.
  Results will be asynchronously returned with the callbacks of the \code
  BKClientResolveDelegate
  \endcode delegate.
  <em>Note</em>: BKResolveSettings.getLanguagePriority() is the only property that takes affect for resolving single elements. All other BKResolveSettings properties are affecting the discovery process only!
  \param input \code
  BKInputElement
  \endcode Data with specified format. therefore see \code
  BKInputElement
  \endcode

*/
- (void)resolveInputElement:(BKInputElement * _Nonnull)input;
/**
  Starts the resolver to retrieve a translated blukii Info Manager news text.
  Results will be asynchronously returned by the delegates of the \code
  BKClientNewsDelegate
  \endcode
  \param languageId language code for the translation, supported languages: \code
  BKResolveSettings.OutputLanguage
  \endcode

*/
- (void)resolveServerNews:(NSString * _Nonnull)languageId;
@end

@class CBPeripheral;
@class BKEddystoneData;
@class BKiBeaconData;
@class BKKeyData;

/**
  Read only data object for emitted data of on BLE module.
  \code
  BKDiscoveryData
  \endcode is a collection of BLE data that is scanned during one scan duration for one BLE module.
  It contains the following values if it is provided by the module’s hardware and firmware
  <ul>
    <li>
      Device found date
    </li>
    <li>
      RSSI value
    </li>
    <li>
      blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
    </li>
    <li>
      Sensor data results of blukii sensor beacons. See \code
      BKBeaconSensorData
      \endcode
    </li>
    <li>
      Key data of blukii SmartKeys. See \code
      BKKeyData
      \endcode
    </li>
    <li>
      Eddystone protocol data values. See \code
      BKEddystoneData
      \endcode
    </li>
    <li>
      iBeacon protocol data values. See \code
      BKiBeaconData
      \endcode
    </li>
  </ul>
  <em>Note</em>: If the scan scan duration (see \code
  BKDiscoverySettings.scanDuration
  \endcode) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the \code
  BKDiscoveryData
  \endcode object.
  The discovery date (\code
  deviceFoundDate
  \endcode) is the timestamp of the first BLE frame that is scanned by the mobile device.
  \code
  BKDiscoveryData
  \endcode is a part of \code
  BKOutputElement
  \endcode
  It will be set if the \code
  BKOutputElement
  \endcode is returned by the delegate function \code
  BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])
  \endcode after calling BKClient.initDiscovery(). For Other BKClient delegates BKDiscoveryData is \code
  nil
  \endcode.
*/
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
/**
  Gets the Timestamp of the first scanned BLE frame that is inside the relevant RSSI range (see setting \code
  BKDiscoverySettings.setRSSIThreshold()
  \endcode).
  This field is set for every scanned BLE module.

  returns:
  Timestamp in milliseconds
*/
@property (nonatomic, readonly, copy) NSDate * _Nullable deviceFoundDate;
/**
  Gets the MacAdress of the BLE module

  returns:
  MAC-Adress of the BLE module
*/
@property (nonatomic, readonly, copy) NSString * _Nullable macAddress;
/**
  Gets the identifier of the BLE module
  This field is set for every scanned BLE module. This value is to prefer, if you want to have a uniqe identifier.

  returns:
  CBPeripheral Identifier
*/
@property (nonatomic, readonly, copy) NSUUID * _Nullable identifier;
/**
  Gets the Device Name of the BLE module.
  This field is set for every scanned BLE module.

  returns:
  Device Name
*/
@property (nonatomic, readonly, copy) NSString * _Nullable deviceName;
/**
  Gets the Bluetooth Device Object (CBPeripheral) of the BLE module.
  This field is set for every scanned BLE module

  returns:
  CBPeripheral Object
*/
@property (nonatomic, readonly, strong) CBPeripheral * _Nullable device;
/**
  Gets a data object of blukii sensor data.
  This field is only valid for blukii beacons that contain sensors.

  returns:
  BeaconSensorData object, \code
  nil
  \endcode if no blukii beacon sensors are available
*/
@property (nonatomic, readonly, strong) BKBeaconSensorData * _Nullable beaconSensorData;
/**
  Gets the firmware number of a blukii
  It is a 4-digit string that you have to inerpret as follows for blukii 2.0: Firmware = ABCD means firmware number A.B.C.D
  For blukii 3.0 you have to interpret as follow: Firmware = AAABBB menas firmware number AAA.BBB

  returns:
  Firmware string, \code
  nil
  \endcode if it is not supported
*/
@property (nonatomic, readonly, copy) NSString * _Nullable firmware;
/**
  Gets the Product ID of a blukii
  This field can be “blukii 2.0” or “blukii 3.0”

  returns:
  Product ID string, nil if it is not supported
*/
@property (nonatomic, readonly, copy) NSString * _Nullable product;
/**
  Gets data object of Eddystone beacon data.
  This field is only valid for beacons that emit Eddystone UID, URL or TLM.

  returns:
  \code
  BKEddystoneData
  \endcode Object, \code
  nil
  \endcode if it is not a Eddystone beacon
*/
@property (nonatomic, readonly, strong) BKEddystoneData * _Nullable eddystoneData;
/**
  Gets a data object of iBeacon data.
  This field is only valid for beacons that emit iBeacon

  returns:
  \code
  BKiBeaconData
  \endcode object, \code
  nil
  \endcode if it is not a iBeacon
*/
@property (nonatomic, readonly, strong) BKiBeaconData * _Nullable iBeaconData;
/**
  Gets a data object of key data.
  this field is only valid for blukii SmartKeys.

  returns:
  KeyData object, nil if it is not a blukii Smart Key
*/
@property (nonatomic, readonly, strong) BKKeyData * _Nullable keyData;
/**
  Gets the advertising interval of a blukii.
  This field is only valid for Blukiis

  returns:
  advertising interval in milliseconds, 0 if is not a blukii
*/
@property (nonatomic, readonly) NSInteger advInterval;
/**
  Gets the battery level value of a blukii

  returns:
  Battery charge in percent, \code
  Int.min
  \endcode if it is not supported
*/
@property (nonatomic, readonly) NSInteger battery;
/**
  Gets the txPower value of a blukii.
  It stands for the physical hardware setting of the BLE sender.
  This field is only valid for blukiis.

  returns:
  TxPower in dBm, \code
  Int16.min
  \endcode if it is not supported.
*/
@property (nonatomic, readonly) int16_t txPower;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
@end


/**
  Property set of settings to configure the discovering process.
  The DiscoverySettings properties are affecting the discovery process that is started by \code
  BKClient.initDiscovery()
  \endcode and the \code
  BKDiscoveryData
  \endcode contents of the result delegate.
  You can access the DiscoverySettings by \code
  BKClient.discoverySettings
  \endcode
  Every setting value is writeable and has a default value that is used if not changed by the developer.
*/
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
/**
  Maximum value for rssi threshold: -20
*/
@property (nonatomic, readonly) NSInteger RSSI_MAX;
/**
  Minimum value for rssi threshold: -120
*/
@property (nonatomic, readonly) NSInteger RSSI_MIN;
/**
  Default value for rssi threshold: -85
*/
@property (nonatomic, readonly) NSInteger RSSI_DEFAULT;
/**
  Gets the rssi threshold for the discovery.
  BLE modules with a higher rssi value will be discovered only.

  returns:
  rssi threshold value, default is \code
  RSSI_DEFAULT
  \endcode
*/
- (NSInteger)getRssiThreshold;
/**
  Sets the rssi threshold for the discovery.
  BLE modules with a higher rssi value will be discovered only.
  The valid range for the rssi threshold is limited by \code
  RSSI_MIN
  \endcode and \code
  RSSI_MAX
  \endcode
*/
- (void)setRssiThreshold:(NSInteger)rssiThreshold;
/**
  Scan duration of one discovery phase: 5000 milliseconds.
*/
@property (nonatomic, readonly) NSInteger SCANDURATION_DEFAULT;
/**
  Value of the duration of one discovery phase in milliseconds. Default is \code
  SCANDURATION_DEFAULT
  \endcode
  After the scan duration has finished all scanned BLE data is saved into a list of BKOutputElement and returned by delegate  \code
  BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])
  \endcode
*/
@property (nonatomic) NSInteger scanDuration;
/**
  Enables / Disables Background scanning.
  <em>Background mode</em>: If the app change to the background, the scan will not stop. Conditions:
  <ul>
    <li>
      capabilities -> Background Modes -> Location Update -> enable
    </li>
    <li>
      capabilities -> Background Modes -> Use Bluetooth LE accessoires -> enable
    </li>
    <li>
      info.plist: Enter a value for NSLocationAlwaysUsageDescription
    </li>
  </ul>
  For power saving BLE scan is only in a iBeacon region active (Default-Region: 01234567-89AB-CDEF-000000000001 and 01234567-89AB-CDEF-000000000002) . If you want to scan an InfoBeacon in Background, you have to configure the blukii smartBeacon in Multimode, so that the blukii smartBeacon send iBeacon an infoBeacon protocol.
*/
@property (nonatomic) BOOL scanInBackground;
/**
  Value, if discovery should scan for non blukii BLE modules.
  <em>Note:</em> The majority of \code
  BKOutputElement
  \endcode data is only supported for blukii modules: \code
  BKBeaconSensorData
  \endcode, \code
  BKResolveData
  \endcode and some value of \code
  BKDiscoveryData
  \endcode. \code
  BKEddystoneData
  \endcode and \code
  BKiBeaconData
  \endcode is also supported for non blukii modules.
  Default value is false
*/
@property (nonatomic) BOOL scanNonBlukiis;
/**
  Sets the stat if discovery should scan for sensor data of blukii beacons.
  If this flag is set \code
  BKOutputElement.discoveryData
  \endcode may contain a valid \code
  BKBeaconSensorData
  \endcode object.
  <em>Note:</em> This flag is only relevant for blukii beacons
  Default value is true
*/
@property (nonatomic) BOOL scanBeaconSensorData;
/**
  Sets the state if discovery should scan for Eddystone data.
  If this flag is set \code
  BKOutputElement.discoveryData
  \endcode may contain a valid \code
  BKEddystoneData
  \endcode object.
  Default value is false
*/
@property (nonatomic) BOOL scanEddystoneData;
/**
  Set the state if discovery should scan for iBeacon data.
  If this flag is set \code
  BKOutputElement.discoveryData
  \endcode may contain a valid \code
  BKiBeaconData
  \endcode object.
  <em>Note:</em> For scanning iBeacons in the info.plist it is reuqiered to enter a value for NSLocationAlwaysUsageDescription.
  Default value is false
*/
@property (nonatomic) BOOL scanIBeaconData;
/**
  Default Value iBeacon UUID Regions
  Values:
  <ul>
    <li>
      01234567-89AB-CDEF-0123-000000000001
    </li>
    <li>
      01234567-89AB-CDEF-0123-000000000002
    </li>
  </ul>
*/
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull IBEACONREGIONS_DEFAULT;
/**
  Set the Regions that will be scanned by the Discovery Service.
  Default Value is IBEACONREGIONS_DEFAULT
  \param regions Array with Region IDs

*/
- (void)setScanIBeaconRegions:(NSArray<NSString *> * _Nonnull)regions;
/**
  Get the Regions that will be scanned by the Discovery Service.

  returns:
  Array with the Region UUID as String
*/
- (NSArray<NSString *> * _Nonnull)getScanIBeaconRegions;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


/**
  Read only data object for Eddystone data that is emitted by beacons
  See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
  \code
  BKEddystoneData
  \endcode can contain data of unencrypted EddyStone UID, URL and TLM.
  \code
  BKEddystoneData
  \endcode values are part of \code
  BKDiscoveryData
  \endcode.
*/
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
/**
  The UIDNamespace if the beacon is emitting an Eddystone UID
*/
@property (nonatomic, readonly, copy) NSString * _Nullable uidNamespace;
/**
  The Instance ID if the beacon is emitting an Eddystone UID
*/
@property (nonatomic, readonly, copy) NSString * _Nullable uidInstance;
/**
  The url string if the beacon is emitting an Eddystone URL
*/
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/**
  The battery charge value if the Beacon is emitting Eddystone TLM

  returns:
  Battery charge in mV, 0 if the blukii has USB power, \code
  Int.min
  \endcode if it is not supported
*/
@property (nonatomic, readonly) NSInteger battery;
/**
  the number of frame packets since the last beacon reset if the beacon is emitting Eddystone TLM

  returns:
  Number of frame packets since last reset, 0 if it is not supported
*/
@property (nonatomic, readonly) NSInteger packets;
/**
  The Time since the last beacon reset if the beacon is emitting Eddystone TLM

  returns:
  Number of seconds since last reset, 0 if it is not supported.
*/
@property (nonatomic, readonly) NSInteger activeTime;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
@end

@class CBCentralManager;

/**
  Helper class to validate application and mobile device features
*/
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
/**
  Checks if the App is on foreground

  returns:
  true if App is on foreground
*/
- (BOOL)isAppOnForeground;
/**
  Checks if the device is connected to the internet.

  returns:
  true if connected to the internet
*/
- (BOOL)isConnectedToInternet;
/**
  Checks if Bluetooth is enabled on the device

  returns:
  true if Bluetooth is enabled
*/
- (BOOL)bluetoothIsEnabled:(CBCentralManager * _Nonnull)centralManager;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/**
  Data Object that defines the input data for resolving requests to blukii Info Manager (https://manager.blukiiinfo.com).
  It is used in two cases:
  <ul>
    <li>
      <em>Delegate</em> \code
      BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])
      \endcode:
    </li>
  </ul>
  \code
  BKInputElement
  \endcode is part of every \code
  BKOutputElement
  \endcode. It contains input type \code
  BKInputSourceTpye.BLUKII
  \endcode and the device name of the discovered BLE module.
  <ul>
    <li>
      <em>Function</em> \code
      BKClient.resolveInputElement(BKInputElement)
      \endcode:
    </li>
  </ul>
  \code
  BKInputElement
  \endcode is used as input property for a single recolving action. It has to be created by initializer \code
  BKInputElement(String, BKInputSourceType)
  \endcode.
  If resolving is successful it will be unmodified part of \code
  BKOutputElement
  \endcode that is returned by delegate \code
  BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)
  \endcode
*/
SWIFT_CLASS("_TtC10BlukiiInfo14BKInputElement")
@interface BKInputElement : NSObject <NSSecureCoding>
/**
  Gets the tag id.

  returns:
  formatted input string
*/
@property (nonatomic, readonly, copy) NSString * _Nonnull tagID;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


/**
  Read only data set for blukii SmartKey
*/
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
/**
  Gets the state if the SmartKey has been time synced since last restart
*/
@property (nonatomic, readonly) BOOL timeSync;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
@end

@class BKResolveData;

/**
  Read only data object for data of BLE discover and resolving process.
  \code
  BKOutputElement
  \endcode is returned by delegates of the BKClient functions for discovery and resolve of BLE modules.
  It is an combination of data that is encapsulated in specific data objects:
  <ul>
    <li>
      \code
      BKInputElement
      \endcode: input data that is created by discovery process (blukii number) or external inputs (NFC tag id, scan of barcodes).
      A cnversion of the \code
      BKInputelement.tagID
      \endcode is saved in \code
      id
      \endcode
    </li>
    <li>
      \code
      BKDiscoveryData
      \endcode: emitted data of the BLE module
    </li>
    <li>
      \code
      BKResolveData
      \endcode: resolved data requested from blukii Info Manager (https://manager.blukiiinfo.com)
      The state of resolve process is saved by \code
      resolveState
      \endcode
    </li>
  </ul>
*/
SWIFT_CLASS("_TtC10BlukiiInfo15BKOutputElement")
@interface BKOutputElement : NSObject <NSSecureCoding>
/**
  The blukii number of the OutputElement
  In Some cases it is a coversion of the input tag id (see \code
  BKInputElement.tagID
  \endcode)
  If it is an iBeacon the id is &lt;UUID&gt;&lt;Major&gt;&lt;Minor&gt;
*/
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/**
  The resolved data from blukii Info Manager (https://manager.blukiiinfo.com)
  For more information see \code
  BKResolveData
  \endcode
  returns the data object of resolved data
*/
@property (nonatomic, readonly, strong) BKResolveData * _Nullable resolveData;
/**
  The emitted BLE data of one module
  For more information see BKDiscoveryData
  returns data object of discovered BLE data
*/
@property (nonatomic, readonly, strong) BKDiscoveryData * _Nullable discoveryData;
/**
  The input data (tag id and type)
  For more Information see \code
  BKInputElement
  \endcode
  returns data object of input data
*/
@property (nonatomic, readonly, strong) BKInputElement * _Nullable inputElement;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
@end


/**
  Read only data object for resolved output data of the blukii info manager
  \code
  BKResolveData
  \endcode can be valid for blukii modules only.
  It contains the result of a data request to the blukii Info Manager (https://manager.blukiiinfo.com).
  The \code
  BKResolveData
  \endcode fields contain the values of on corresponding blukii number.
  \code
  BKResolveData
  \endcode is part of \code
  BKOutputElement
  \endcode
  It will be set for the following cases:
  <ul>
    <li>
      OutputElement ID (see \code
      BKOutputElement.id
      \endcode) must be configured as a blukii number on the blukii Info Manager by an Info Manger user. This is an requierement for all \code
      BKClient
      \endcode delegates!
    </li>
    <li>
      \code
      BKResolveData
      \endcode will be requested during the discovery (see \code
      BKClient.initDiscovery()
      \endcode) for all discovered Elelements if the setting \code
      BKResolveSettings.resolveEnabled
      \endcode is set true. If some data is responded it will be returned as part of an \code
      BKOutputElement
      \endcode by delegate \code
      BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])
      \endcode The result state of resolving can additionally be read by calling \code
      BKOuputElement.resolveState
      \endcode:
      <ul>
        <li>
          UNRESOLVED: Resolve is off (\code
          BKResolveSettings.resolveEnabled
          \endcode is false) or blukii Info Manager is not connectable
        </li>
        <li>
          RESOLVED: blukii Info Manager has responded data for the OutputElement ID
        </li>
        <li>
          NODATA: blukii Info Manager is connectable but has responded no data for the OutputElement ID
        </li>
        <li>
          CACHED: ResolveData contains cached data that has been responded earlier (see cache settings on \code
          BKResolveSettings
          \endcode)
        </li>
      </ul>
    </li>
    <li>
      \code
      BKResolveData
      \endcode will be requested for a single Element by calling (see \code
      BKClient.resolveInputElement(BKInputElement)
      \endcode). If some data is responded it will be returned as part of an \code
      BKOutputElement
      \endcode by delegate \code
      BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)
      \endcode. The result state of resolving can additionally be read by calling \code
      BKOutputElement.resolveState
      \endcode. For single element requests there is no cache available.
      <ul>
        <li>
          RESOLVED: blukii Info Manager has responded data for the OutputElement ID
        </li>
        <li>
          NODATA: blukii Info Manager has not responded data for the OutputElement ID
        </li>
      </ul>
    </li>
  </ul>
*/
SWIFT_CLASS("_TtC10BlukiiInfo13BKResolveData")
@interface BKResolveData : NSObject <NSSecureCoding>
/**
  The value of the language specific blukii number field <em>Title</em>
  The language is defined by property \code
  language
  \endcode.
  <em>Note:</em> If the language specific field <em>Title</em> is not set \code
  title
  \endcode contains the value of field <em>Name</em> (as fallback)
  Value of blukii number field <em>Title</em>
*/
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/**
  The Value of the language specific blukii number field <em>URL</em>
  The language is defined by property \code
  language
  \endcode
  <em>Note:</em> In most cases getUrl returns an url to a OutputType specific file. Exceptions are:
  <ul>
    <li>
      OutputType \code
      BKOutputType.MESSAGE
      \endcode: The message text itself will be returned.
    </li>
    <li>
      Resolving single elements of \code
      BKInputSourceType.SCAN
      \endcode by \code
      BlukiiClient.resolveInputElement(BKInputElement)
      \endcode: If you resolve a QR code with format \code
      BKOutputType.WIFI
      \endcode or \code
      BKOutputType.VCARD
      \endcode the WIFI or VCARD formatted code will be returned.
    </li>
  </ul>
*/
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/**
  The output language of the BKResolveData set.
  It shows the language specific selection of the blukii number fields \code
  url
  \endcode and \code
  title
  \endcode, for \code
  BKOutputType.PDF
  \endcode also of \code
  urlExtra
  \endcode and \code
  plainTextExtra
  \endcode
  The output language is chosen by the resolver process. If only one language specific blukii number URL and title is defined it will be returned. Otherwise the language is chosen according the language priority setting (see \code
  BKResolveSettings.getLanguagePriority()
  \endcode)
  The value can be one of the following languages codes: en-gb, fr-fr or de-de
*/
@property (nonatomic, readonly, copy) NSString * _Nullable language;
/**
  Gets the value of the language specific blukii number field <em>Audio File URL</em>.
  The language is defined by property \code
  language
  \endcode.
  <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (see \code
  outputType
  \endcode). It contains a url of an audio file.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable urlExtra;
/**
  The value of the language specific blukii number field <em>Text to speech</em>.
  The language is defined by property \code
  language
  \endcode.
  <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (see \code
  outputType
  \endcode). It contains a text.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable plainTextExtra;
/**
  The value of the date where the blukii Number was resolved

  returns:
  NSDate object
*/
@property (nonatomic, readonly, copy) NSDate * _Nonnull resolveDate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
@end


/**
  Property set of settings to configure the resolving process of data from blukii Info Manager (https://manager.blukiiinfo.com)
  You can access the BKResolveSettings by calling \code
  BKClient.resolveSettings
  \endcode
  Every settings value is writeable and has a default value that is used if not changed by the developer.
  With the exception of \code
  getLanguagePriority()
  \endcode the ResolveSettings properties are only affecting the discovery process that is started by \code
  BKClient.initDiscovery()
  \endcode
  For the single resolving process that is started by \code
  BKClient.resolveInputElement(input: BKInputElement)
  \endcode only \code
  getLanguagePriority()
  \endcode is relevant.
*/
SWIFT_CLASS("_TtC10BlukiiInfo17BKResolveSettings")
@interface BKResolveSettings : NSObject
/**
  Gets the language priority that is relevant for the selection of the language specific \code
  BKResolveData
  \endcode fields like url and title.

  returns:
  String Array of language ids, default is \code
  LANGUAGEPRIORITY_DEFAULT
  \endcode (de-de, fr-fr, en-gb)
*/
- (NSArray<NSString *> * _Nonnull)getLanguagePriorityString;
/**
  Sets the language priority that is relevant for the selection of the language specific \code
  BKResolveData
  \endcode fields like url and title
  \param localeIds array of String language ids (de-de, fr-fr, en-gb)

*/
- (BOOL)setLanguagePriority:(NSArray<NSString *> * _Nonnull)localeIds;
/**
  The state if the resolver is enabled for discovered BLE modules
  Default: false
*/
@property (nonatomic) BOOL resolveEnabled;
/**
  Default cache timeout: 180000 milliseconds (30 mintues)
*/
@property (nonatomic, readonly) NSInteger CACHETIMEOUT_DEFAULT;
/**
  The Timeout for the resolver cache.
  You can use this feature to minimize network traffic by caching resolved values. If \code
  BKResolveData
  \endcode is found for one blukii number the next network request will be done again only after cache timeout.
  You have to consider the following application states to define when caching should be enabled:
  <ul>
    <li>
      \code
      isCacheEnabledOnForeground()
      \endcode: App is in foreground
    </li>
    <li>
      \code
      isCacheEnabledOnBackground()
      \endcode: App is in background
    </li>
  </ul>
  Cache Timout in milliseconds, default is \code
  CACHETIMEOUT_DEFAULT
  \endcode
*/
@property (nonatomic) NSInteger cacheTimeout;
/**
  The state if cache is enabled when App is in foreground
  cache enabled state, default is false
*/
@property (nonatomic) BOOL cacheEnabledOnForeground;
/**
  The state if cache is enabled when App is in background
  cache enabled state, default is true
*/
@property (nonatomic) BOOL cacheEnabledOnBackground;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class NSNumber;

/**
  <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
  See iBeacon specification at https://developer.apple.com/ibeacon
  iBeaconData values are part of \code
  BKDiscoveryData
  \endcode
*/
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/**
  The UUID if the beacon is emitting iBeacon
*/
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/**
  The Major ID if the beacon is emitting iBeacon
*/
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/**
  The Minor ID if the beacon is emitting iBeacon
*/
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

#pragma clang diagnostic pop
