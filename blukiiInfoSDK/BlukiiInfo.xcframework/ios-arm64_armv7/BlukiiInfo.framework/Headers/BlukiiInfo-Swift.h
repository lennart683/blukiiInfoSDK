#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
#ifndef BLUKIIINFO_SWIFT_H
#define BLUKIIINFO_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="BlukiiInfo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

/// Read only data set for 3D axis data
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
/// The x-Axis value
///
/// returns:
/// x-axis value. Int16.min if not set.
@property (nonatomic, readonly) int16_t x;
/// The y-Axis value
///
/// returns:
/// y-axis value. Int16.min if not set.
@property (nonatomic, readonly) int16_t y;
/// The z-Axis value
///
/// returns:
/// z-axis value. Int16.min if not set.
@property (nonatomic, readonly) int16_t z;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for sensor data that is emitted by blukii beacons
/// BeaconSensor values are part of <code>BKDiscoveryData</code>
/// seealso:
/// <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
/// The value of the air pressure sensor. (Read-Only)
/// If the beacon does not emit air pressure the default value is Int16.min
///
/// returns:
/// Air pressure in hP
@property (nonatomic, readonly) float airPressure;
/// The value of the light sensor. (Read-Only)
/// If the beacon does not emit light the default value is Int16.min
///
/// returns:
/// Light in Lux
@property (nonatomic, readonly) int16_t light;
/// The value of the humidity sensor. (Read-Only)
/// If the beacon does not emit humidity the default value is Int16.min
///
/// returns:
/// Humidity in percent (%)
@property (nonatomic, readonly) int16_t humidity;
/// The value of the temperature sensor. (Read-Only)
/// If the beacon does not emit temperature the default value is Float()
///
/// returns:
/// Temperature in degrees Celsius (°C)
@property (nonatomic, readonly) float temperature;
/// The 3D axis Valuee of the acceleration sensor.
/// <em>Note:</em> If the scan duration longer than one advertising interval duration the maximum value of each axis is returned
///
/// returns:
/// AxisData values of acceleration
@property (nonatomic, readonly, strong) BKAxisData * _Nullable acceleration;
/// The  3D axis values of magnetism sensor.
/// <em>Note:</em> If the scan duration is longer than one advertising interval duration the maximum value of each axis is returned
///
/// returns:
/// AxisData values of magnetism
@property (nonatomic, readonly, strong) BKAxisData * _Nullable magnetism;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Main controller class of package info, for interacting with blukii Manager Info CMS (@see  https://manager.blukii.com)
/// BlukiiClient class contains discovery functions as follows:
/// <ul>
///   <li>
///     Request for getting blukii Info output data.
///   </li>
///   <li>
///     Reporting of blukii Info clicks.
///   </li>
///   <li>
///     Reporting of blukii Info violations.
///   </li>
/// </ul>
/// <em>Note:</em> These functions needs to set an developers API key by <code>BKBlukiiCloud.setApiKey(apiKey:)</code>. Settings of credentials and user login is not needed for BlukiiInfo functions.
SWIFT_CLASS("_TtC10BlukiiInfo12BKBlukiiInfo")
@interface BKBlukiiInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum BlukiiType represents the types a blukii can have
typedef SWIFT_ENUM(NSInteger, BKBlukiiType, open) {
/// Blukii Type “Unknown”
  BKBlukiiTypeUnknown = 0,
/// Blukii Type “SmartKey”
  BKBlukiiTypeSmartKey = 1,
/// Blukii Type “SmartBeacon”
  BKBlukiiTypeSmartBeacon = 2,
/// Blukii Type “SensorBeacon”
  BKBlukiiTypeSensorBeacon = 3,
};

@protocol BKClientDiscoveryDelegate;
@protocol BKDecryptSecureBeaconsDelegate;
@class BKDiscoverySettings;
@class BKDiscoveryData;

/// <h1>Main Controller class for discovering BLE modules</h1>
/// BlukiiClient is a single point of contact for all data retieving actions as follows:
/// <ul>
///   <li>
///     Discovering BLE modules, extracting BLE advertised data
///   </li>
///   <li>
///     Decryption of blukii SecureBeacon advertising
///   </li>
/// </ul>
/// <h2>A. Discover BLE modules and extract their BLE data</h2>
/// To do this you have to do the following steps:
/// <h3>1. Initialize and start discovery</h3>
/// Call <code>initDiscovery()</code> and implement the <code>BKClientDiscoveryDelegate</code> delegates. After initialization is ready (<code>BKClientDiscoveryDelegate.onDiscoveryInitialized()</code>) you can start the discovery.
/// \code
///  var mBlukiiClient: BKClient!
///
///  override func viewDidLoad() {
///      ...
///      mBlukiiClient = BKController.instance.getDiscoveryClient()
///      mBlukiiClient.discoveryDelegate = self
///      mBlukiiClient.initDiscovery()
///      ...
///  }
///
///  func stopDiscovery() {
///      mBlukiiClient.stopDiscovery()
///  }
///
///  // Discovery Delegate
///  func onDiscoveryInitialized() {
///      if mBlukiiClient.startDiscovery() {
///          // Discovery successfully started
///      }
///  }
///
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///      // retrieve BLE results
///  }
///
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // retrieve errors
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // retrieve infos and changed states
///  }
///
/// \endcode<h3>2. Configure discovery settings</h3>
/// Use the <code>BKDiscoverySettings</code> object for configuring discovery. Get <code>BKClient.discoverySettings</code> to retrieve the settings property set.
/// \code
///  func onInitialized() {
///        // Discovery successfully initialized
///
///        let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///        discoverySettings.setRssiThreshold(-100)
///        discoverySettings.scanDuration = 10000
///        ...
///
///        if mBlukiiClient.startDiscovery() {
///            // Discovery successfully started
///        }
///   }
///
/// \endcodeWhen BLE scanner is started the BLE discovery is acting according to the <code>BKDiscoverySettings</code>:
/// <ul>
///   <li>
///     The scanner is searching for BLE modules inside the defined rssi range (<code>BKDiscoverySettings.getRssiThreshold()</code>).
///   </li>
///   <li>
///     After one scan duration (<code>BKDiscoverySettings.scanDuration</code>) the results are called back to (<code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>)
///   </li>
///   <li>
///     This is repeated until BLE Scanning is stopped by <code>BKClient.stopDiscovery()</code> or the app did enter the background.
///   </li>
///   <li>
///     if the scanner is paused according to the <code>BKDiscoverySettings</code> the info <code>BKDiscoveryInfo.bleScanPaused</code> is called.
///   </li>
///   <li>
///     For background scanning it is necessary to be in the Configured iBeacon Region. Background scanning will only Scan, if the device is in the configured iBeacon Region and the display will be switched on.  In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
///   </li>
/// </ul>
/// <h3>3. Retrieve results</h3>
/// The callback <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code> will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
/// <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
/// \code
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///    // Discovery phase has finished: list of OutputElements are retrieved
///
///    for discoveryData in discoveryResultList {
///       let id = discoveryData.blukiiId
///       let rssi = discoveryData.getRssi()
///       ...
///    }
///  }
///
/// \endcode<h3>4. Retrieve errors and infos</h3>
/// The callbacks <code>BKClientDiscoveryDelegate.onDiscoveryError(_:)</code> and <code>BKClientDiscoveryDelegate.onDiscoveryInfo(_:)</code> will be called if there is important information about the discover process.
/// \code
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // An error has been sent from discover
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // An info has been sent from discovery
///  }
///
/// \endcode<h3>5. Permission</h3>
/// In Info.plist set the following keys for Beacon Detection:
/// <ul>
///   <li>
///     NSLocationAlwaysUsageDescription
///   </li>
///   <li>
///     NSBluetoothAlwaysUsageDescription
///   </li>
/// </ul>
/// Add the Follow Capapilities to your Project, for scanning Beacons in Background:
/// <ul>
///   <li>
///     Background Mode: Location Updates
///   </li>
///   <li>
///     Background Mode: Uses Bluetooth LE accessoires
///   </li>
/// </ul>
/// <h2>B. Decryption of SecureBeacon advertising</h2>
/// blukii SecureBeacons are encrypted to prevent third parties from misusing the Beacon identification.
/// The encryption is affecting the mac address and the iBeacon Major and Minor value.
/// You can decrypt DiscoveryData by calling  <code> decryptSecureBeacons(discoveryDataList:)</code>. To detect a SecureBeacon, you have to set your secureBeacon UUID to <code>BKDiscoverySettings.securebeaconUUID</code>
/// The delegate <code>BKDecryptSecureBeaconsDelegate.onDecryptSecureBeacons(_:decryptedCount:)</code>  is retrieving a copy of the input parameter list containing decrypted values. Each BKDiscoveryData object, that has been decrypted is marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.decrypted</code>.
/// \code
/// func onDecryptSecureBeacons(_ decryptedDiscoveryDataList: [BKDiscoveryData], decryptedCount: Int) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons Successful: Count=" +  decryptedCount)
/// }
///
/// func onDecryptError(_ error: Error) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons failed: error=" + error.localizedDescription)
/// }
///
/// \endcode<em>Note:</em> SecureBeacons can only be decrypted by its owner, so the corresponding user needs to be logged in (@see <code>BKBlukiiCloud</code>)
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/// Discovery Delegate for BLE discovery
@property (nonatomic, strong) id <BKClientDiscoveryDelegate> _Nullable discoveryDelegate;
/// SecureBeacon Decryption Delegate
@property (nonatomic, strong) id <BKDecryptSecureBeaconsDelegate> _Nullable decryptSecureBeaconDelegate;
/// Discovery Settings
@property (nonatomic, readonly, strong) BKDiscoverySettings * _Null_unspecified discoverySettings;
/// Constructor for initiating a blukii client.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Gets the state if BLE scanner is actuallly running.
///
/// returns:
/// true, if BLE scanner is scanning
- (BOOL)isDiscovering SWIFT_WARN_UNUSED_RESULT;
/// Initializes the discovery service.
/// If successful, the delegate <code>BKClientDiscoveryDelegate.onDiscoveryInitialized()</code> is called.
/// Otherwise the delegate <code>BKClientDiscoveryDelegate.onDiscoveryError(_:)</code> is called with an error.
/// <em>Note</em>: By calling this function the service instance BKDeviceDiscoveryService is started and binded by the BKClient object. This is required before calling <code>startDiscovery()</code> and <code>stopDiscovery()</code> for starting and stopping the discovery for BLE modules. Without <code>startDiscovery()</code> <code>BKClient</code> is not do any action and therefore not using the battery.
/// <em>Note</em>: Use this function only, if the view is loaded. For Example viewDidAppear.
- (void)initDiscovery SWIFT_METHOD_FAMILY(none);
/// Gets the state if the discovery service is initialized.
///
/// returns:
/// true, if discovery service is initialized
- (BOOL)isDiscoveryInitialized SWIFT_WARN_UNUSED_RESULT;
/// Starts the BLE scanner.
/// It only can be started if the discovery service has been initialized befor by calling <code>initDiscovery()</code>!
/// <em>Note</em>: Only when the BLE scanner is started successfully the <code>BKClientDiscoveryDelegate</code> delegates are called if there is any discovery result, error or info.
/// You can stop scanning by calling <code>stopDiscovery()</code>
///
/// returns:
/// true, if start is successful.
- (BOOL)startDiscovery SWIFT_WARN_UNUSED_RESULT;
/// Stops the BLE scanner.
/// You can start scanning by calling <code>startDiscovery()</code>
///
/// returns:
/// true, if stop is successful.
- (BOOL)stopDiscovery SWIFT_WARN_UNUSED_RESULT;
/// The Default SecureBeacon cache Timeout
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger SECUREBEACON_CACHETIMEOUT_DEFAULT;)
+ (NSInteger)SECUREBEACON_CACHETIMEOUT_DEFAULT SWIFT_WARN_UNUSED_RESULT;
/// Gets the current cache timeout for secure beacon decryption. If value is 0, cache is off.
///
/// returns:
/// Timeout in seconds
- (NSInteger)getDecryptSecureBeaconCacheTimeout SWIFT_WARN_UNUSED_RESULT;
/// Sets the current cache timeout for secure beacon decryption. If value is 0, cache is off.
/// \param Timeout is in seconds 
///
- (void)setDecryptSecureBeaconCacheTimeout:(NSInteger)decryptSecureBeaconCacheTimeout;
/// Tries to decrypt the <code>discoveryDataList</code> list items that are marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.encrypted</code>. If successful <code>BKDecryptSecureBeaconsDelegate.onDecryptSecureBeacons(_:decryptedCount:)</code> is called with the result list, otherwise <code>BKDecryptSecureBeaconsDelegate.onDecryptError(_:)</code> is called. Therefore an blukii Manager user authentication via <code>BKBlukiiCloud.login()</code> is needed.
/// \param discoveryDataList discoveryData Array that needs to be decrypted
///
- (void)decryptSecureBeaconsWithDiscoveryDataList:(NSArray<BKDiscoveryData *> * _Nonnull)discoveryDataList;
@end

enum BKDiscoveryError : NSInteger;
enum BKDiscoveryInfo : NSInteger;

/// Delegate for the BLE discovery.
/// Discovery delegates are registred by <code>BKClient.discoveryDelegate</code>
SWIFT_PROTOCOL("_TtP10BlukiiInfo25BKClientDiscoveryDelegate_")
@protocol BKClientDiscoveryDelegate
/// Will be called when the BKDeviceDiscoveryService is initialized
- (void)onDiscoveryInitialized;
/// Will be called frequently after one scan duration for returning the scan results.
/// If no BLE modules has been found <code>discoveryResultList</code> list is an empty list (not <code>nil</code>).
/// If the discovery failed because of an error <code>onDiscoveryResult(_:)</code> will not be called.
/// \param discoveryResultList list of discovered <code>BKDiscoveryData</code>
///
- (void)onDiscoveryResult:(NSArray<BKDiscoveryData *> * _Nonnull)discoveryResultList;
/// Will be called if discovery or resolver fail because of an error
/// \param errorCode error code
///
- (void)onDiscoveryError:(enum BKDiscoveryError)errorCode;
/// Will be called for discovery state information
/// \param infoCode info code
///
- (void)onDiscoveryInfo:(enum BKDiscoveryInfo)infoCode;
@end

/// Enum that represents an the state of ON, OFF and UNDEFINED
typedef SWIFT_ENUM(NSInteger, BKCommonState, open) {
/// State On
  BKCommonStateOn = 0,
/// State Off
  BKCommonStateOff = 1,
/// State Undefined
  BKCommonStateUndefined = 2,
};


/// Main controller of blukii SDK
/// BlukiiController controls the instantiation of all controllers that can only be loaded by BlukiiController.
/// Please note: There must be only one BlukiiController instance to prevent multiple instantiations of package controllers and data structures.
/// Example Snippet
/// \code
/// override func viewDidLoad() {
///    ...
///    mBlukiiCloud = BKController.instance.getCloud()
///    ...
/// }
///
/// \endcode
SWIFT_CLASS("_TtC10BlukiiInfo12BKController")
@interface BKController : NSObject
/// Gets an instance of BlukiiController.
///
/// returns:
/// An instance of <code>BKController</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) BKController * _Nonnull instance;)
+ (BKController * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Gets an instance of the discovery main controller class <code>BKClient</code>.
///
/// returns:
/// An instance of <code>BKClient</code>
- (BKClient * _Nonnull)getDiscoveryClient SWIFT_WARN_UNUSED_RESULT;
/// Gets an instance of the info main controller class <code>BKBlukiiInfo</code>
///
/// returns:
/// An instance of  <code>BKBlukiiInfo</code>
- (BKBlukiiInfo * _Nonnull)getInfoClient SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Delegate for the SecureBeacon decryption
/// Decrypt Delegate is registred by <code>BKClient.decryptSecureBeaconDelegate</code>
SWIFT_PROTOCOL("_TtP10BlukiiInfo30BKDecryptSecureBeaconsDelegate_")
@protocol BKDecryptSecureBeaconsDelegate
/// Will be called if <code>BKClient.decryptSecureBeacons(discoveryDataList:)</code> is successfully requested. Parameter <code>decryptedDiscoveryDataList</code> contains all list items contained as parameter in <code>BKClient.decryptSecureBeacons(discoveryDataList:)</code>. If the authenticated blukii Manager user is owner of list items that are marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.encrypted</code>, these are decrypted.
/// \param decryptedDiscoveryDataList result list of discoveryData objects
///
/// \param decryptedCount count of items that are decrypted
///
- (void)onDecryptSecureBeacons:(NSArray<BKDiscoveryData *> * _Nonnull)decryptedDiscoveryDataList decryptedCount:(NSInteger)decryptedCount;
/// Will be called if <code>BKClient.decryptSecureBeacons(discoveryDataList:)</code> requested has done with errors.
/// \param error Contains an error message
///
- (void)onDecryptError:(NSError * _Nonnull)error;
@end

@class CBPeripheral;
enum BKSecureBeaconState : NSInteger;
@class BKEddystoneData;
@class BKiBeaconData;
@class BKKeyData;

/// Read only data object for emitted data of on BLE module.
/// <code>BKDiscoveryData</code> is a collection of BLE data that is scanned during one scan duration for one BLE module.
/// It contains the following values if it is provided by the module’s hardware and firmware
/// <ul>
///   <li>
///     Device found date
///   </li>
///   <li>
///     RSSI value
///   </li>
///   <li>
///     blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
///   </li>
///   <li>
///     Sensor data results of blukii sensor beacons. See <code>BKBeaconSensorData</code>
///   </li>
///   <li>
///     Key data of blukii SmartKeys. See <code>BKKeyData</code>
///   </li>
///   <li>
///     Eddystone protocol data values. See <code>BKEddystoneData</code>
///   </li>
///   <li>
///     iBeacon protocol data values. See <code>BKiBeaconData</code>
///   </li>
/// </ul>
/// <em>Note</em>: If the scan scan duration (see <code>BKDiscoverySettings.scanDuration</code>) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the <code>BKDiscoveryData</code> object.
/// The discovery date (<code>deviceFoundDate</code>) is the timestamp of the last BLE frame that is scanned by the mobile device.
/// <code>BKDiscoveryData</code> is returned by teh delegate function <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
/// Gets the Timestamp of the first scanned BLE frame that is inside the relevant RSSI range (see setting <code>BKDiscoverySettings.setRSSIThreshold(_:)</code>).
/// This field is set for every scanned BLE module.
///
/// returns:
/// Timestamp in milliseconds
@property (nonatomic, readonly, copy) NSDate * _Nullable deviceFoundDate;
/// Gets the MacAdress of the BLE module
///
/// returns:
/// MAC-Adress of the BLE module
@property (nonatomic, readonly, copy) NSString * _Nullable macAddress;
/// The blukii Id of the BLE module.
/// This field is set for blukii modules only.
///
/// returns:
/// blukii ID
@property (nonatomic, readonly, copy) NSString * _Nullable blukiiId;
/// Gets the identifier of the BLE module
/// This field is set for every scanned BLE module. This value is to prefer, if you want to have a uniqe identifier.
///
/// returns:
/// CBPeripheral Identifier
@property (nonatomic, readonly, copy) NSUUID * _Nullable identifier;
/// Gets the Device Name of the BLE module.
/// This field is set for every scanned BLE module.
///
/// returns:
/// Device Name
@property (nonatomic, readonly, copy) NSString * _Nullable deviceName;
/// Gets the Bluetooth Device Object (<code>CBPeripheral</code>) of the BLE module.
/// This field is set for every scanned BLE module
///
/// returns:
/// <code>CBPeripheral</code> Object
@property (nonatomic, readonly, strong) CBPeripheral * _Nullable device;
/// Gets the state if blukii is advertising secure beacon values.
/// This field is only valid for blukii SmartBeacons.
/// This field is only valid, if the <code>BKDiscoverySettings.securebeaconUUID</code> is set correct.
///
/// returns:
/// <code>BKSecureBeaconState</code>
@property (nonatomic, readonly) enum BKSecureBeaconState secureBeaconState;
/// Gets the state if blukii is advertising event beacon values.
/// This field is only valid for blukii SmartBeacons, since firmware 002.010
///
/// returns:
/// <code>BKCommonState</code>
@property (nonatomic, readonly) enum BKCommonState eventBeaconState;
/// Gets a data object of blukii sensor data.
/// This field is only valid for blukii beacons that contain sensors.
///
/// returns:
/// <code>BKBeaconSensorData</code> object, <code>nil</code> if no blukii beacon sensors are available
@property (nonatomic, readonly, strong) BKBeaconSensorData * _Nullable beaconSensorData;
/// Gets the firmware number of a blukii
/// It is a 4-digit string that you have to inerpret as follows for blukii 2.0: Firmware = ABCD means firmware number A.B.C.D
/// For blukii 3.0 you have to interpret as follow: Firmware = AAABBB menas firmware number AAA.BBB
///
/// returns:
/// Firmware string, <code>nil</code> if it is not supported
@property (nonatomic, readonly, copy) NSString * _Nullable firmware;
/// Gets the Product ID of a blukii
/// This field can be “blukii 2.0” or “blukii 3.0”
///
/// returns:
/// Product ID string, <code>nil</code> if it is not supported
@property (nonatomic, readonly, copy) NSString * _Nullable product;
/// Checks if blukii Service Mode is active.
/// Service Mode is active for 30 seconds are re-inserting the battery.
/// It is needed for security relevant configurations, e.g. for SmartKey
///
/// returns:
/// true, if blukii Service Mode is active
@property (nonatomic, readonly) BOOL serviceMode;
/// Gets data object of Eddystone beacon data.
/// This field is only valid for beacons that emit Eddystone UID, URL or TLM.
///
/// returns:
/// <code>BKEddystoneData</code> Object, <code>nil</code> if it is not a Eddystone beacon
@property (nonatomic, readonly, strong) BKEddystoneData * _Nullable eddystoneData;
/// Gets a data object of iBeacon data.
/// This field is only valid for beacons that emit iBeacon
///
/// returns:
/// <code>BKiBeaconData</code> object, <code>nil</code> if it is not a iBeacon
@property (nonatomic, readonly, strong) BKiBeaconData * _Nullable iBeaconData;
/// Gets a data object of key data.
/// this field is only valid for blukii SmartKeys.
///
/// returns:
/// KeyData object, nil if it is not a blukii Smart Key
@property (nonatomic, readonly, strong) BKKeyData * _Nullable keyData;
/// Gets the module type
///
/// returns:
/// Modul Type as BlukiiType
@property (nonatomic, readonly) enum BKBlukiiType type;
/// Gets the advertising interval of a blukii.
/// This field is only valid for Blukiis
///
/// returns:
/// advertising interval in milliseconds, 0 if is not a blukii
@property (nonatomic, readonly) NSInteger advInterval;
/// Gets the battery level value of a blukii
///
/// returns:
/// Battery charge in percent, <code>Int.min</code> if it is not supported
@property (nonatomic, readonly) NSInteger battery;
/// Gets the txPower value of a blukii.
/// It stands for the physical hardware setting of the BLE sender.
/// This field is only valid for blukiis.
///
/// returns:
/// TxPower in dBm, <code>Int16.min</code> if it is not supported.
@property (nonatomic, readonly) int16_t txPower;
/// Gets the RSSI value of the scanned BLE module.
/// It depends on the Flag <code>BKDiscoverySettings.calculatingRssiAverage</code> how the rssi value is calculated:
/// <ul>
///   <li>
///     flag is true: The average value of all BLE frames is calculated.
///   </li>
///   <li>
///     flag is false: The value of the last BLE frame is takedn.
///     <em>Note:</em> BLE frames are only relevant if they are insede the RSSI range (@see setting <code>BKDiscoverySettings.setRssiThreshold(_:)</code>
///   </li>
/// </ul>
/// This field is set for every scanned BLE module.
///
/// returns:
/// Int Rssi Value
- (NSInteger)getRssi SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

/// Error codes for discovery functions of class <code>BKClient</code>
typedef SWIFT_ENUM(NSInteger, BKDiscoveryError, open) {
/// Initialization of the discovery service has failed.
  BKDiscoveryErrorInitFailed = 0,
/// Termination of the discovery service has failed.
  BKDiscoveryErrorTerminationFailed = 1,
/// Bluetooth is off on the mobile device.
  BKDiscoveryErrorBluetoothOff = 2,
/// Bluetooth is on on the mobile device.
  BKDiscoveryErrorBluetoothOn = 3,
/// The BLE scanner cannot be started by an unknown error.
  BKDiscoveryErrorStartBleFailed = 4,
/// The BLE scanner cannot be stopped by an unknown error.
  BKDiscoveryErrorStopBleFailed = 5,
/// The Location Service has not the permission Always
  BKDiscoveryErrorLocationServicesIsNotAlways = 6,
};

/// Info codes for discovery functions of class BKClient
typedef SWIFT_ENUM(NSInteger, BKDiscoveryInfo, open) {
/// The BLE scanner has been started successfully.
  BKDiscoveryInfoBleScanStarted = 0,
/// The BLE scanner has been stopped successfully.
  BKDiscoveryInfoBleScanStopped = 1,
/// The BLE scanner has been paused because of the DiscoverySettings.
  BKDiscoveryInfoBleScanPaused = 2,
};

@class CLBeaconRegion;

/// Property set of settings to configure the discovering process.
/// The DiscoverySettings properties are affecting the discovery process that is started by <code>BKClient.initDiscovery()</code> and the <code>BKDiscoveryData</code> contents of the result delegate.
/// You can access the DiscoverySettings by <code>BKClient.discoverySettings</code>
/// Every setting value is writeable and has a default value that is used if not changed by the developer.
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
/// Maximum value for rssi threshold: -20
@property (nonatomic, readonly) NSInteger RSSI_MAX;
/// Minimum value for rssi threshold: -120
@property (nonatomic, readonly) NSInteger RSSI_MIN;
/// Default value for rssi threshold: -85
@property (nonatomic, readonly) NSInteger RSSI_DEFAULT;
/// Gets the rssi threshold for the discovery.
/// BLE modules with a higher rssi value will be discovered only.
///
/// returns:
/// rssi threshold value, default is <code>RSSI_DEFAULT</code>
- (NSInteger)getRssiThreshold SWIFT_WARN_UNUSED_RESULT;
/// Sets the rssi threshold for the discovery.
/// BLE modules with a higher rssi value will be discovered only.
/// The valid range for the rssi threshold is limited by <code>RSSI_MIN</code> and <code>RSSI_MAX</code>
- (void)setRssiThreshold:(NSInteger)rssiThreshold;
/// The state if discovery should calculate the average RSSI of all scanned frames.
/// Otherwise the last found RSSI Value is returned on <code>BKDiscoveryData.getRssi()</code>
/// Default value is true
///
/// returns:
/// true, if Rssi average is calculated
@property (nonatomic) BOOL calculatingRssiAverage;
/// Scan duration of one discovery phase: 2000 milliseconds.
@property (nonatomic, readonly) NSInteger SCANDURATION_DEFAULT;
/// Value of the duration of one discovery phase in milliseconds. Default is <code>SCANDURATION_DEFAULT</code>
/// After the scan duration has finished all scanned BLE data is saved into a list of BKOutputElement and returned by delegate  <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>
@property (nonatomic) NSInteger scanDuration;
/// Scan Wait duration between two discovery phase: 15000 milliseconds
@property (nonatomic, readonly) NSInteger SCANWAITDURATION_DEFAULT;
/// Value of the waiting time between two discovery phase in milliseconds. Default is <code>SCANWAITDURATION_DEFAULT</code>
@property (nonatomic) NSInteger scanWaitDuration;
/// Default Value for disableWaitTimeAtStartForTime
@property (nonatomic, readonly) NSInteger DISABLESCANWAITTIMEATSTARTFORTIME_DEFAULT;
/// Value of the Time in seconds, wich the scanWaitDuration will be disabled, at the start of a scan. Default is <code>DISABLESCANWAITTIMEATSTARTFORTIME_DEFAULT</code>
@property (nonatomic) NSInteger disableScanWaitTimeAtStartForTime;
/// Enables / Disables Background scanning.
/// <em>Background mode</em>: If the app change to the background, the scan will not stop. Conditions:
/// <ul>
///   <li>
///     capabilities -> Background Modes -> Location Update -> enable
///   </li>
///   <li>
///     capabilities -> Background Modes -> Use Bluetooth LE accessoires -> enable
///   </li>
///   <li>
///     info.plist: Enter a value for <code>NSLocationAlwaysUsageDescription</code>
///   </li>
/// </ul>
/// For power saving BLE scan is only in a iBeacon region active (Default-Region: 626c756b-6969-2e63-6f6d-6576656e7473) . If you want to scan an InfoBeacon in Background, you have to configure the blukii smartBeacon in Multimode, so that the blukii smartBeacon send iBeacon an infoBeacon protocol.
@property (nonatomic) BOOL scanInBackground;
/// State if the scan wait duration between two discovery phases is disabled on background. Default value is <code>false</code>
@property (nonatomic) BOOL scanContinuouslyOnBackground;
/// Sate if the scan wait duration between two discovery phases is disabled on foreground. Default value is <code>true</code>
@property (nonatomic) BOOL scanContinuouslyOnForeground;
/// Value, if discovery should scan for non blukii BLE modules.
/// <em>Note:</em> The majority of <code>BKDiscoveryData</code> data is only supported for blukii modules: <code>BKBeaconSensorData</code>, <code>BKInfoData</code> and some value of <code>BKDiscoveryData</code>. <code>BKEddystoneData</code> and <code>BKiBeaconData</code> is also supported for non blukii modules.
/// Default value is false
@property (nonatomic) BOOL scanNonBlukiis;
/// the state if discovery should  scan for basic blukii data like firmware, advertising interval, etc.
/// default is true
@property (nonatomic) BOOL scanBlukiiData;
/// Sets the stat if discovery should scan for sensor data of blukii beacons.
/// If this flag is set <code>BKDiscoveryData</code> may contain a valid <code>BKBeaconSensorData</code> object.
/// <em>Note:</em> This flag is only relevant for blukii beacons
/// Default value is true
@property (nonatomic) BOOL scanBeaconSensorData;
/// Sets the state if discovery should scan for Eddystone data.
/// If this flag is set <code>BKDiscoveryData</code> may contain a valid <code>BKEddystoneData</code> object.
/// Default value is false
@property (nonatomic) BOOL scanEddystoneData;
/// Set the state if discovery should scan for iBeacon data.
/// If this flag is set <code>BKDiscoveryData</code> may contain a valid <code>BKiBeaconData</code> object.
/// <em>Note:</em> For scanning iBeacons in the info.plist it is reuqiered to enter a value for NSLocationAlwaysUsageDescription.
/// Default value is false
@property (nonatomic) BOOL scanIBeaconData;
/// Default Value iBeacon UUID Regions
/// Values:
/// <ul>
///   <li>
///     01234567-89AB-CDEF-0123-000000000001: old blukii Default
///   </li>
///   <li>
///     626c756b-6969-2e63-6f6d-6576656e7473: new blukii Default
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull IBEACONREGIONS_DEFAULT SWIFT_DEPRECATED_MSG("Please use ibeaconRegionsDefault()");
/// Default Value iBeacon UUID Regions
/// Values:
///
/// returns:
/// The default Values for blukii beacons
- (NSArray<CLBeaconRegion *> * _Nonnull)ibeaconRegionsDefault SWIFT_WARN_UNUSED_RESULT;
/// Set the for detection of secureBeacon UUID
/// This UUID must also be  set at <code>setScanIBeaconRegions(regions:)</code> for detection of the secureBeacon
@property (nonatomic, copy) NSUUID * _Nonnull securebeaconUUID;
/// Set the Regions that will be scanned by the Discovery Service.
/// Default Value is IBEACONREGIONS_DEFAULT
/// Note: You can Use the setScanIBeaconRegions(regions: [CLBeaconRegion]) function or this function
/// If both functions are set, the last one is taken.
/// \param regions Array with Region IDs
///
- (void)setScanIBeaconRegionsWithRegionStrings:(NSArray<NSString *> * _Nonnull)regions SWIFT_DEPRECATED_MSG("Please use setScanIBeaconRegions(regions: [CLBeaconRegion])");
/// Get the Regions that will be scanned by the Discovery Service.
///
/// returns:
/// Array with the Region UUID as String
- (NSArray<CLBeaconRegion *> * _Nonnull)getScanIBeaconRegions SWIFT_WARN_UNUSED_RESULT;
/// Set teh Regions that will be scanned by teh Discovery Service
/// Default is <code>ibeaconRegionsDefault()</code>
/// Note: You can Use this function or the function <code>setScanIBeaconRegions(regionStrings:)</code>
/// If both functions are set, the last one is taken.
/// \param regions Array with Region IDs
///
- (void)setScanIBeaconRegionsWithRegions:(NSArray<CLBeaconRegion *> * _Nonnull)regions;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Read only data object for Eddystone data that is emitted by beacons
/// See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
/// <code>BKEddystoneData</code> can contain data of unencrypted EddyStone UID, URL and TLM.
/// <code>BKEddystoneData</code> values are part of <code>BKDiscoveryData</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
/// The UIDNamespace if the beacon is emitting an Eddystone UID
@property (nonatomic, readonly, copy) NSString * _Nullable uidNamespace;
/// The Instance ID if the beacon is emitting an Eddystone UID
@property (nonatomic, readonly, copy) NSString * _Nullable uidInstance;
/// The url string if the beacon is emitting an Eddystone URL
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// The txPower value if the beacon is emitting Eddystone TLM.
/// It stands for the measured RSSI value when the distance between the beacon and the mobile device is 0 meter.
///
/// returns:
/// txPower in dBm, <code>Int16.min</code> if it is not supported
@property (nonatomic, readonly) int16_t txPower;
/// The battery charge value if the Beacon is emitting Eddystone TLM
///
/// returns:
/// Battery charge in mV, 0 if the blukii has USB power, <code>Int.min</code> if it is not supported
@property (nonatomic, readonly) NSInteger battery;
/// The Temperature value if the beacon is emitting Eddystone TLM.
///
/// returns:
/// Temperature in degress Celsius (°C), <code>Float()</code> if it is not supported
@property (nonatomic, readonly) float temperature;
/// the number of frame packets since the last beacon reset if the beacon is emitting Eddystone TLM
///
/// returns:
/// Number of frame packets since last reset, 0 if it is not supported
@property (nonatomic, readonly) NSInteger packets;
/// The Time since the last beacon reset if the beacon is emitting Eddystone TLM
///
/// returns:
/// Number of seconds since last reset, 0 if it is not supported.
@property (nonatomic, readonly) NSInteger activeTime;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Helper class to validate application and mobile device features
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
/// Checks if the App is on foreground
///
/// returns:
/// true if App is on foreground
- (BOOL)isAppOnForeground SWIFT_WARN_UNUSED_RESULT;
/// Checks if the device is connected to the internet.
///
/// returns:
/// true if connected to the internet
- (BOOL)isConnectedToInternet SWIFT_WARN_UNUSED_RESULT;
/// Checks if Bluetooth is enabled on the device
///
/// returns:
/// true if Bluetooth is enabled
- (BOOL)bluetoothIsEnabled SWIFT_WARN_UNUSED_RESULT;
/// Checks if Bluetooth access is allowed
///
/// returns:
/// true if Bluetooth is allowed for the current app
- (BOOL)bluetoothAccessDenied SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoBundleOutputData;

/// Read only data object for Info Bundle data retrieved from blukii Manager Info CMS.
/// It contains the results of the <code>BKBlukiiInfo.getInfoBundles(bundleIds:completionHandler:)</code> request to the blukii Manager Info CMS (https://manager.blukii.com).
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoBundleData")
@interface BKInfoBundleData : NSObject <NSCoding>
/// The Bundle Id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The map of bundle output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> Englisch
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this dictionary only contains ouput data of languages that are configured for the Bundle on blukii Manager CMS.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoBundleOutputData *> * _Nonnull outputDataList;
/// If the InfoData items has been marked as protected.
/// true, if protedted
@property (nonatomic, readonly) BOOL itemsProtected;
/// The timestamp of last retrieve from blukii Manager.
/// timestamp in milliseconds
@property (nonatomic, readonly) int64_t timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
@end


/// Read only data object for output language based info bundle data retrieved from blukii Manager Info CMS.
/// It is a child object of  <code>BKInfoBundleData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo22BKInfoBundleOutputData")
@interface BKInfoBundleOutputData : NSObject <NSCoding>
/// The value of the language specific Title.
/// <em>Note:</em> If the language specific field Title is not set title contains the value of field <code>BKInfoBundleData.name</code> (as fallback).
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The url of the Bundles Preview Image.
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoOutputData;

/// Read only data object for data of BLE discover and resolving process.
/// It contains the results of the <code>BKBlukiiInfo.getInfoData(blukiiIds:completionHandler:)</code> request to the blukii Manager Info CMS(https://manager.blukii.com).
/// The BKInfoData fields contain the values of one corresponding blukii number.
SWIFT_CLASS("_TtC10BlukiiInfo10BKInfoData")
@interface BKInfoData : NSObject <NSSecureCoding>
/// The Info data id.
///
/// returns:
/// id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The blukii Numbers of the Info.
///
/// returns:
/// Blukii Id list
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull blukiiList;
/// The map of Info output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> English
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this map only contains output data of languages that are configured for the Info on blukii Manager CMS.
///
/// returns:
/// map of ouput data
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoOutputData *> * _Nonnull outputDataList;
/// The value of the blukii number field Visibility range.
/// This value contains a Bluetooth module defined value for the rssi range in addition to the global rssi setting (@see <code>BKDiscoverySettings.getRssiThreshold()</code>.
/// It does not affect the BLE scan itself but is designed for a better output handling.
///
/// returns:
/// Value of blukii number field Visibility range
@property (nonatomic, readonly) int64_t rssi;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nullable condition;
/// The identifiable name of the Info data.
///
/// returns:
/// Info Data Name
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// :nodoc:
@property (nonatomic, readonly) NSInteger infoProviderId;
/// The timestamp of last retrieve from blukii Manager.
///
/// returns:
/// Timestamp as <code>Date</code>
@property (nonatomic, readonly, copy) NSDate * _Nonnull timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for output language based blukii data retrieved from blukii Manager Info CMS.
/// It is a child object of <code>BKInfoData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoOutputData")
@interface BKInfoOutputData : NSObject <NSCoding>
/// The value of output <em>Title</em>
///
/// returns:
/// Value of Title
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The value of output <em>URL</em>.
///
/// returns:
/// Value of URL
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// Gets the url of <em>preview Image</em>
///
/// returns:
/// Value of preview url
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
/// The value of the <em>Audio File URL</em>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a url of an audio file.
///
/// returns:
/// Value of Audio File URL of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable urlExtra;
/// The value of  <em>Text to speech</em>.
/// The language is defined by property <code>language</code>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a text.
///
/// returns:
/// Value of Text to speech of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable plainTextExtra;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
@end

enum Mode : NSInteger;

/// Read only data set for blukii SmartKey
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
/// Gets the state if the SmartKey has been time synced since last restart
@property (nonatomic, readonly) BOOL timeSync;
/// Gets the operating mode of the Smart Key that determines the security level
@property (nonatomic, readonly) enum Mode mode;
/// The state if the SmartKey has been pushed.
/// <em>Note:</em> only supported for blukiis with push button
@property (nonatomic, readonly) BOOL isButtonPushed;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

/// Operating mode of the Smart Key that determines the security level
typedef SWIFT_ENUM(NSInteger, Mode, open) {
/// No mode is configured
  ModeOFF = 0,
/// low security level; authentication via BLE device address
  ModeCONVENIENCE = 1,
/// medium security level; authentication via pairing key
  ModePAIRING = 2,
/// MODE_SECURE, pairing key is not yet set
  ModeSECURE_PREPARED = 3,
/// high security level; authentication via AES128 encrypted key and pairing key
  ModeSECURE = 4,
};

/// Indicates if blukii SmartBeacon is sending SecureBeacon advertising and if <code>BKDiscoveryData</code> object contains encrypted data.
typedef SWIFT_ENUM(NSInteger, BKSecureBeaconState, open) {
/// blukii SmartBeacon is not a SecureBeacon
/// To detect this correct, set the correct UUID in <code>BKDiscoverySettings.securebeaconUUID</code>
  BKSecureBeaconStateOff = 0,
/// blukii SmartBeacon is a SecureBeacon. DiscoveryData contains encrypted mac address and iBeacon Major and Minor values.
  BKSecureBeaconStateEncrypted = 1,
/// blukii SmartBeacon is a SecureBeacon. DiscoveryData contains decrypted mac address and iBeacon Major and Minor values.
  BKSecureBeaconStateDecrypted = 2,
};

@class NSNumber;

/// <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
/// See iBeacon specification at https://developer.apple.com/ibeacon
/// iBeaconData values are part of <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/// The UUID if the beacon is emitting iBeacon
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/// The Major ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/// The Minor ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
/// The relative distance to the beacon.
@property (nonatomic, readonly) CLProximity proximity;
/// The accuracy of the proximity value, measured in meters from the beacon.
@property (nonatomic, readonly) CLLocationAccuracy accuracy;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__ARM_ARCH_7A__) && __ARM_ARCH_7A__
// Generated by Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
#ifndef BLUKIIINFO_SWIFT_H
#define BLUKIIINFO_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="BlukiiInfo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

/// Read only data set for 3D axis data
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
/// The x-Axis value
///
/// returns:
/// x-axis value. Int16.min if not set.
@property (nonatomic, readonly) int16_t x;
/// The y-Axis value
///
/// returns:
/// y-axis value. Int16.min if not set.
@property (nonatomic, readonly) int16_t y;
/// The z-Axis value
///
/// returns:
/// z-axis value. Int16.min if not set.
@property (nonatomic, readonly) int16_t z;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for sensor data that is emitted by blukii beacons
/// BeaconSensor values are part of <code>BKDiscoveryData</code>
/// seealso:
/// <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
/// The value of the air pressure sensor. (Read-Only)
/// If the beacon does not emit air pressure the default value is Int16.min
///
/// returns:
/// Air pressure in hP
@property (nonatomic, readonly) float airPressure;
/// The value of the light sensor. (Read-Only)
/// If the beacon does not emit light the default value is Int16.min
///
/// returns:
/// Light in Lux
@property (nonatomic, readonly) int16_t light;
/// The value of the humidity sensor. (Read-Only)
/// If the beacon does not emit humidity the default value is Int16.min
///
/// returns:
/// Humidity in percent (%)
@property (nonatomic, readonly) int16_t humidity;
/// The value of the temperature sensor. (Read-Only)
/// If the beacon does not emit temperature the default value is Float()
///
/// returns:
/// Temperature in degrees Celsius (°C)
@property (nonatomic, readonly) float temperature;
/// The 3D axis Valuee of the acceleration sensor.
/// <em>Note:</em> If the scan duration longer than one advertising interval duration the maximum value of each axis is returned
///
/// returns:
/// AxisData values of acceleration
@property (nonatomic, readonly, strong) BKAxisData * _Nullable acceleration;
/// The  3D axis values of magnetism sensor.
/// <em>Note:</em> If the scan duration is longer than one advertising interval duration the maximum value of each axis is returned
///
/// returns:
/// AxisData values of magnetism
@property (nonatomic, readonly, strong) BKAxisData * _Nullable magnetism;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Main controller class of package info, for interacting with blukii Manager Info CMS (@see  https://manager.blukii.com)
/// BlukiiClient class contains discovery functions as follows:
/// <ul>
///   <li>
///     Request for getting blukii Info output data.
///   </li>
///   <li>
///     Reporting of blukii Info clicks.
///   </li>
///   <li>
///     Reporting of blukii Info violations.
///   </li>
/// </ul>
/// <em>Note:</em> These functions needs to set an developers API key by <code>BKBlukiiCloud.setApiKey(apiKey:)</code>. Settings of credentials and user login is not needed for BlukiiInfo functions.
SWIFT_CLASS("_TtC10BlukiiInfo12BKBlukiiInfo")
@interface BKBlukiiInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum BlukiiType represents the types a blukii can have
typedef SWIFT_ENUM(NSInteger, BKBlukiiType, open) {
/// Blukii Type “Unknown”
  BKBlukiiTypeUnknown = 0,
/// Blukii Type “SmartKey”
  BKBlukiiTypeSmartKey = 1,
/// Blukii Type “SmartBeacon”
  BKBlukiiTypeSmartBeacon = 2,
/// Blukii Type “SensorBeacon”
  BKBlukiiTypeSensorBeacon = 3,
};

@protocol BKClientDiscoveryDelegate;
@protocol BKDecryptSecureBeaconsDelegate;
@class BKDiscoverySettings;
@class BKDiscoveryData;

/// <h1>Main Controller class for discovering BLE modules</h1>
/// BlukiiClient is a single point of contact for all data retieving actions as follows:
/// <ul>
///   <li>
///     Discovering BLE modules, extracting BLE advertised data
///   </li>
///   <li>
///     Decryption of blukii SecureBeacon advertising
///   </li>
/// </ul>
/// <h2>A. Discover BLE modules and extract their BLE data</h2>
/// To do this you have to do the following steps:
/// <h3>1. Initialize and start discovery</h3>
/// Call <code>initDiscovery()</code> and implement the <code>BKClientDiscoveryDelegate</code> delegates. After initialization is ready (<code>BKClientDiscoveryDelegate.onDiscoveryInitialized()</code>) you can start the discovery.
/// \code
///  var mBlukiiClient: BKClient!
///
///  override func viewDidLoad() {
///      ...
///      mBlukiiClient = BKController.instance.getDiscoveryClient()
///      mBlukiiClient.discoveryDelegate = self
///      mBlukiiClient.initDiscovery()
///      ...
///  }
///
///  func stopDiscovery() {
///      mBlukiiClient.stopDiscovery()
///  }
///
///  // Discovery Delegate
///  func onDiscoveryInitialized() {
///      if mBlukiiClient.startDiscovery() {
///          // Discovery successfully started
///      }
///  }
///
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///      // retrieve BLE results
///  }
///
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // retrieve errors
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // retrieve infos and changed states
///  }
///
/// \endcode<h3>2. Configure discovery settings</h3>
/// Use the <code>BKDiscoverySettings</code> object for configuring discovery. Get <code>BKClient.discoverySettings</code> to retrieve the settings property set.
/// \code
///  func onInitialized() {
///        // Discovery successfully initialized
///
///        let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///        discoverySettings.setRssiThreshold(-100)
///        discoverySettings.scanDuration = 10000
///        ...
///
///        if mBlukiiClient.startDiscovery() {
///            // Discovery successfully started
///        }
///   }
///
/// \endcodeWhen BLE scanner is started the BLE discovery is acting according to the <code>BKDiscoverySettings</code>:
/// <ul>
///   <li>
///     The scanner is searching for BLE modules inside the defined rssi range (<code>BKDiscoverySettings.getRssiThreshold()</code>).
///   </li>
///   <li>
///     After one scan duration (<code>BKDiscoverySettings.scanDuration</code>) the results are called back to (<code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>)
///   </li>
///   <li>
///     This is repeated until BLE Scanning is stopped by <code>BKClient.stopDiscovery()</code> or the app did enter the background.
///   </li>
///   <li>
///     if the scanner is paused according to the <code>BKDiscoverySettings</code> the info <code>BKDiscoveryInfo.bleScanPaused</code> is called.
///   </li>
///   <li>
///     For background scanning it is necessary to be in the Configured iBeacon Region. Background scanning will only Scan, if the device is in the configured iBeacon Region and the display will be switched on.  In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
///   </li>
/// </ul>
/// <h3>3. Retrieve results</h3>
/// The callback <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code> will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
/// <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
/// \code
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///    // Discovery phase has finished: list of OutputElements are retrieved
///
///    for discoveryData in discoveryResultList {
///       let id = discoveryData.blukiiId
///       let rssi = discoveryData.getRssi()
///       ...
///    }
///  }
///
/// \endcode<h3>4. Retrieve errors and infos</h3>
/// The callbacks <code>BKClientDiscoveryDelegate.onDiscoveryError(_:)</code> and <code>BKClientDiscoveryDelegate.onDiscoveryInfo(_:)</code> will be called if there is important information about the discover process.
/// \code
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // An error has been sent from discover
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // An info has been sent from discovery
///  }
///
/// \endcode<h3>5. Permission</h3>
/// In Info.plist set the following keys for Beacon Detection:
/// <ul>
///   <li>
///     NSLocationAlwaysUsageDescription
///   </li>
///   <li>
///     NSBluetoothAlwaysUsageDescription
///   </li>
/// </ul>
/// Add the Follow Capapilities to your Project, for scanning Beacons in Background:
/// <ul>
///   <li>
///     Background Mode: Location Updates
///   </li>
///   <li>
///     Background Mode: Uses Bluetooth LE accessoires
///   </li>
/// </ul>
/// <h2>B. Decryption of SecureBeacon advertising</h2>
/// blukii SecureBeacons are encrypted to prevent third parties from misusing the Beacon identification.
/// The encryption is affecting the mac address and the iBeacon Major and Minor value.
/// You can decrypt DiscoveryData by calling  <code> decryptSecureBeacons(discoveryDataList:)</code>. To detect a SecureBeacon, you have to set your secureBeacon UUID to <code>BKDiscoverySettings.securebeaconUUID</code>
/// The delegate <code>BKDecryptSecureBeaconsDelegate.onDecryptSecureBeacons(_:decryptedCount:)</code>  is retrieving a copy of the input parameter list containing decrypted values. Each BKDiscoveryData object, that has been decrypted is marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.decrypted</code>.
/// \code
/// func onDecryptSecureBeacons(_ decryptedDiscoveryDataList: [BKDiscoveryData], decryptedCount: Int) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons Successful: Count=" +  decryptedCount)
/// }
///
/// func onDecryptError(_ error: Error) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons failed: error=" + error.localizedDescription)
/// }
///
/// \endcode<em>Note:</em> SecureBeacons can only be decrypted by its owner, so the corresponding user needs to be logged in (@see <code>BKBlukiiCloud</code>)
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/// Discovery Delegate for BLE discovery
@property (nonatomic, strong) id <BKClientDiscoveryDelegate> _Nullable discoveryDelegate;
/// SecureBeacon Decryption Delegate
@property (nonatomic, strong) id <BKDecryptSecureBeaconsDelegate> _Nullable decryptSecureBeaconDelegate;
/// Discovery Settings
@property (nonatomic, readonly, strong) BKDiscoverySettings * _Null_unspecified discoverySettings;
/// Constructor for initiating a blukii client.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Gets the state if BLE scanner is actuallly running.
///
/// returns:
/// true, if BLE scanner is scanning
- (BOOL)isDiscovering SWIFT_WARN_UNUSED_RESULT;
/// Initializes the discovery service.
/// If successful, the delegate <code>BKClientDiscoveryDelegate.onDiscoveryInitialized()</code> is called.
/// Otherwise the delegate <code>BKClientDiscoveryDelegate.onDiscoveryError(_:)</code> is called with an error.
/// <em>Note</em>: By calling this function the service instance BKDeviceDiscoveryService is started and binded by the BKClient object. This is required before calling <code>startDiscovery()</code> and <code>stopDiscovery()</code> for starting and stopping the discovery for BLE modules. Without <code>startDiscovery()</code> <code>BKClient</code> is not do any action and therefore not using the battery.
/// <em>Note</em>: Use this function only, if the view is loaded. For Example viewDidAppear.
- (void)initDiscovery SWIFT_METHOD_FAMILY(none);
/// Gets the state if the discovery service is initialized.
///
/// returns:
/// true, if discovery service is initialized
- (BOOL)isDiscoveryInitialized SWIFT_WARN_UNUSED_RESULT;
/// Starts the BLE scanner.
/// It only can be started if the discovery service has been initialized befor by calling <code>initDiscovery()</code>!
/// <em>Note</em>: Only when the BLE scanner is started successfully the <code>BKClientDiscoveryDelegate</code> delegates are called if there is any discovery result, error or info.
/// You can stop scanning by calling <code>stopDiscovery()</code>
///
/// returns:
/// true, if start is successful.
- (BOOL)startDiscovery SWIFT_WARN_UNUSED_RESULT;
/// Stops the BLE scanner.
/// You can start scanning by calling <code>startDiscovery()</code>
///
/// returns:
/// true, if stop is successful.
- (BOOL)stopDiscovery SWIFT_WARN_UNUSED_RESULT;
/// The Default SecureBeacon cache Timeout
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger SECUREBEACON_CACHETIMEOUT_DEFAULT;)
+ (NSInteger)SECUREBEACON_CACHETIMEOUT_DEFAULT SWIFT_WARN_UNUSED_RESULT;
/// Gets the current cache timeout for secure beacon decryption. If value is 0, cache is off.
///
/// returns:
/// Timeout in seconds
- (NSInteger)getDecryptSecureBeaconCacheTimeout SWIFT_WARN_UNUSED_RESULT;
/// Sets the current cache timeout for secure beacon decryption. If value is 0, cache is off.
/// \param Timeout is in seconds 
///
- (void)setDecryptSecureBeaconCacheTimeout:(NSInteger)decryptSecureBeaconCacheTimeout;
/// Tries to decrypt the <code>discoveryDataList</code> list items that are marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.encrypted</code>. If successful <code>BKDecryptSecureBeaconsDelegate.onDecryptSecureBeacons(_:decryptedCount:)</code> is called with the result list, otherwise <code>BKDecryptSecureBeaconsDelegate.onDecryptError(_:)</code> is called. Therefore an blukii Manager user authentication via <code>BKBlukiiCloud.login()</code> is needed.
/// \param discoveryDataList discoveryData Array that needs to be decrypted
///
- (void)decryptSecureBeaconsWithDiscoveryDataList:(NSArray<BKDiscoveryData *> * _Nonnull)discoveryDataList;
@end

enum BKDiscoveryError : NSInteger;
enum BKDiscoveryInfo : NSInteger;

/// Delegate for the BLE discovery.
/// Discovery delegates are registred by <code>BKClient.discoveryDelegate</code>
SWIFT_PROTOCOL("_TtP10BlukiiInfo25BKClientDiscoveryDelegate_")
@protocol BKClientDiscoveryDelegate
/// Will be called when the BKDeviceDiscoveryService is initialized
- (void)onDiscoveryInitialized;
/// Will be called frequently after one scan duration for returning the scan results.
/// If no BLE modules has been found <code>discoveryResultList</code> list is an empty list (not <code>nil</code>).
/// If the discovery failed because of an error <code>onDiscoveryResult(_:)</code> will not be called.
/// \param discoveryResultList list of discovered <code>BKDiscoveryData</code>
///
- (void)onDiscoveryResult:(NSArray<BKDiscoveryData *> * _Nonnull)discoveryResultList;
/// Will be called if discovery or resolver fail because of an error
/// \param errorCode error code
///
- (void)onDiscoveryError:(enum BKDiscoveryError)errorCode;
/// Will be called for discovery state information
/// \param infoCode info code
///
- (void)onDiscoveryInfo:(enum BKDiscoveryInfo)infoCode;
@end

/// Enum that represents an the state of ON, OFF and UNDEFINED
typedef SWIFT_ENUM(NSInteger, BKCommonState, open) {
/// State On
  BKCommonStateOn = 0,
/// State Off
  BKCommonStateOff = 1,
/// State Undefined
  BKCommonStateUndefined = 2,
};


/// Main controller of blukii SDK
/// BlukiiController controls the instantiation of all controllers that can only be loaded by BlukiiController.
/// Please note: There must be only one BlukiiController instance to prevent multiple instantiations of package controllers and data structures.
/// Example Snippet
/// \code
/// override func viewDidLoad() {
///    ...
///    mBlukiiCloud = BKController.instance.getCloud()
///    ...
/// }
///
/// \endcode
SWIFT_CLASS("_TtC10BlukiiInfo12BKController")
@interface BKController : NSObject
/// Gets an instance of BlukiiController.
///
/// returns:
/// An instance of <code>BKController</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) BKController * _Nonnull instance;)
+ (BKController * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Gets an instance of the discovery main controller class <code>BKClient</code>.
///
/// returns:
/// An instance of <code>BKClient</code>
- (BKClient * _Nonnull)getDiscoveryClient SWIFT_WARN_UNUSED_RESULT;
/// Gets an instance of the info main controller class <code>BKBlukiiInfo</code>
///
/// returns:
/// An instance of  <code>BKBlukiiInfo</code>
- (BKBlukiiInfo * _Nonnull)getInfoClient SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Delegate for the SecureBeacon decryption
/// Decrypt Delegate is registred by <code>BKClient.decryptSecureBeaconDelegate</code>
SWIFT_PROTOCOL("_TtP10BlukiiInfo30BKDecryptSecureBeaconsDelegate_")
@protocol BKDecryptSecureBeaconsDelegate
/// Will be called if <code>BKClient.decryptSecureBeacons(discoveryDataList:)</code> is successfully requested. Parameter <code>decryptedDiscoveryDataList</code> contains all list items contained as parameter in <code>BKClient.decryptSecureBeacons(discoveryDataList:)</code>. If the authenticated blukii Manager user is owner of list items that are marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.encrypted</code>, these are decrypted.
/// \param decryptedDiscoveryDataList result list of discoveryData objects
///
/// \param decryptedCount count of items that are decrypted
///
- (void)onDecryptSecureBeacons:(NSArray<BKDiscoveryData *> * _Nonnull)decryptedDiscoveryDataList decryptedCount:(NSInteger)decryptedCount;
/// Will be called if <code>BKClient.decryptSecureBeacons(discoveryDataList:)</code> requested has done with errors.
/// \param error Contains an error message
///
- (void)onDecryptError:(NSError * _Nonnull)error;
@end

@class CBPeripheral;
enum BKSecureBeaconState : NSInteger;
@class BKEddystoneData;
@class BKiBeaconData;
@class BKKeyData;

/// Read only data object for emitted data of on BLE module.
/// <code>BKDiscoveryData</code> is a collection of BLE data that is scanned during one scan duration for one BLE module.
/// It contains the following values if it is provided by the module’s hardware and firmware
/// <ul>
///   <li>
///     Device found date
///   </li>
///   <li>
///     RSSI value
///   </li>
///   <li>
///     blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
///   </li>
///   <li>
///     Sensor data results of blukii sensor beacons. See <code>BKBeaconSensorData</code>
///   </li>
///   <li>
///     Key data of blukii SmartKeys. See <code>BKKeyData</code>
///   </li>
///   <li>
///     Eddystone protocol data values. See <code>BKEddystoneData</code>
///   </li>
///   <li>
///     iBeacon protocol data values. See <code>BKiBeaconData</code>
///   </li>
/// </ul>
/// <em>Note</em>: If the scan scan duration (see <code>BKDiscoverySettings.scanDuration</code>) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the <code>BKDiscoveryData</code> object.
/// The discovery date (<code>deviceFoundDate</code>) is the timestamp of the last BLE frame that is scanned by the mobile device.
/// <code>BKDiscoveryData</code> is returned by teh delegate function <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
/// Gets the Timestamp of the first scanned BLE frame that is inside the relevant RSSI range (see setting <code>BKDiscoverySettings.setRSSIThreshold(_:)</code>).
/// This field is set for every scanned BLE module.
///
/// returns:
/// Timestamp in milliseconds
@property (nonatomic, readonly, copy) NSDate * _Nullable deviceFoundDate;
/// Gets the MacAdress of the BLE module
///
/// returns:
/// MAC-Adress of the BLE module
@property (nonatomic, readonly, copy) NSString * _Nullable macAddress;
/// The blukii Id of the BLE module.
/// This field is set for blukii modules only.
///
/// returns:
/// blukii ID
@property (nonatomic, readonly, copy) NSString * _Nullable blukiiId;
/// Gets the identifier of the BLE module
/// This field is set for every scanned BLE module. This value is to prefer, if you want to have a uniqe identifier.
///
/// returns:
/// CBPeripheral Identifier
@property (nonatomic, readonly, copy) NSUUID * _Nullable identifier;
/// Gets the Device Name of the BLE module.
/// This field is set for every scanned BLE module.
///
/// returns:
/// Device Name
@property (nonatomic, readonly, copy) NSString * _Nullable deviceName;
/// Gets the Bluetooth Device Object (<code>CBPeripheral</code>) of the BLE module.
/// This field is set for every scanned BLE module
///
/// returns:
/// <code>CBPeripheral</code> Object
@property (nonatomic, readonly, strong) CBPeripheral * _Nullable device;
/// Gets the state if blukii is advertising secure beacon values.
/// This field is only valid for blukii SmartBeacons.
/// This field is only valid, if the <code>BKDiscoverySettings.securebeaconUUID</code> is set correct.
///
/// returns:
/// <code>BKSecureBeaconState</code>
@property (nonatomic, readonly) enum BKSecureBeaconState secureBeaconState;
/// Gets the state if blukii is advertising event beacon values.
/// This field is only valid for blukii SmartBeacons, since firmware 002.010
///
/// returns:
/// <code>BKCommonState</code>
@property (nonatomic, readonly) enum BKCommonState eventBeaconState;
/// Gets a data object of blukii sensor data.
/// This field is only valid for blukii beacons that contain sensors.
///
/// returns:
/// <code>BKBeaconSensorData</code> object, <code>nil</code> if no blukii beacon sensors are available
@property (nonatomic, readonly, strong) BKBeaconSensorData * _Nullable beaconSensorData;
/// Gets the firmware number of a blukii
/// It is a 4-digit string that you have to inerpret as follows for blukii 2.0: Firmware = ABCD means firmware number A.B.C.D
/// For blukii 3.0 you have to interpret as follow: Firmware = AAABBB menas firmware number AAA.BBB
///
/// returns:
/// Firmware string, <code>nil</code> if it is not supported
@property (nonatomic, readonly, copy) NSString * _Nullable firmware;
/// Gets the Product ID of a blukii
/// This field can be “blukii 2.0” or “blukii 3.0”
///
/// returns:
/// Product ID string, <code>nil</code> if it is not supported
@property (nonatomic, readonly, copy) NSString * _Nullable product;
/// Checks if blukii Service Mode is active.
/// Service Mode is active for 30 seconds are re-inserting the battery.
/// It is needed for security relevant configurations, e.g. for SmartKey
///
/// returns:
/// true, if blukii Service Mode is active
@property (nonatomic, readonly) BOOL serviceMode;
/// Gets data object of Eddystone beacon data.
/// This field is only valid for beacons that emit Eddystone UID, URL or TLM.
///
/// returns:
/// <code>BKEddystoneData</code> Object, <code>nil</code> if it is not a Eddystone beacon
@property (nonatomic, readonly, strong) BKEddystoneData * _Nullable eddystoneData;
/// Gets a data object of iBeacon data.
/// This field is only valid for beacons that emit iBeacon
///
/// returns:
/// <code>BKiBeaconData</code> object, <code>nil</code> if it is not a iBeacon
@property (nonatomic, readonly, strong) BKiBeaconData * _Nullable iBeaconData;
/// Gets a data object of key data.
/// this field is only valid for blukii SmartKeys.
///
/// returns:
/// KeyData object, nil if it is not a blukii Smart Key
@property (nonatomic, readonly, strong) BKKeyData * _Nullable keyData;
/// Gets the module type
///
/// returns:
/// Modul Type as BlukiiType
@property (nonatomic, readonly) enum BKBlukiiType type;
/// Gets the advertising interval of a blukii.
/// This field is only valid for Blukiis
///
/// returns:
/// advertising interval in milliseconds, 0 if is not a blukii
@property (nonatomic, readonly) NSInteger advInterval;
/// Gets the battery level value of a blukii
///
/// returns:
/// Battery charge in percent, <code>Int.min</code> if it is not supported
@property (nonatomic, readonly) NSInteger battery;
/// Gets the txPower value of a blukii.
/// It stands for the physical hardware setting of the BLE sender.
/// This field is only valid for blukiis.
///
/// returns:
/// TxPower in dBm, <code>Int16.min</code> if it is not supported.
@property (nonatomic, readonly) int16_t txPower;
/// Gets the RSSI value of the scanned BLE module.
/// It depends on the Flag <code>BKDiscoverySettings.calculatingRssiAverage</code> how the rssi value is calculated:
/// <ul>
///   <li>
///     flag is true: The average value of all BLE frames is calculated.
///   </li>
///   <li>
///     flag is false: The value of the last BLE frame is takedn.
///     <em>Note:</em> BLE frames are only relevant if they are insede the RSSI range (@see setting <code>BKDiscoverySettings.setRssiThreshold(_:)</code>
///   </li>
/// </ul>
/// This field is set for every scanned BLE module.
///
/// returns:
/// Int Rssi Value
- (NSInteger)getRssi SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

/// Error codes for discovery functions of class <code>BKClient</code>
typedef SWIFT_ENUM(NSInteger, BKDiscoveryError, open) {
/// Initialization of the discovery service has failed.
  BKDiscoveryErrorInitFailed = 0,
/// Termination of the discovery service has failed.
  BKDiscoveryErrorTerminationFailed = 1,
/// Bluetooth is off on the mobile device.
  BKDiscoveryErrorBluetoothOff = 2,
/// Bluetooth is on on the mobile device.
  BKDiscoveryErrorBluetoothOn = 3,
/// The BLE scanner cannot be started by an unknown error.
  BKDiscoveryErrorStartBleFailed = 4,
/// The BLE scanner cannot be stopped by an unknown error.
  BKDiscoveryErrorStopBleFailed = 5,
/// The Location Service has not the permission Always
  BKDiscoveryErrorLocationServicesIsNotAlways = 6,
};

/// Info codes for discovery functions of class BKClient
typedef SWIFT_ENUM(NSInteger, BKDiscoveryInfo, open) {
/// The BLE scanner has been started successfully.
  BKDiscoveryInfoBleScanStarted = 0,
/// The BLE scanner has been stopped successfully.
  BKDiscoveryInfoBleScanStopped = 1,
/// The BLE scanner has been paused because of the DiscoverySettings.
  BKDiscoveryInfoBleScanPaused = 2,
};

@class CLBeaconRegion;

/// Property set of settings to configure the discovering process.
/// The DiscoverySettings properties are affecting the discovery process that is started by <code>BKClient.initDiscovery()</code> and the <code>BKDiscoveryData</code> contents of the result delegate.
/// You can access the DiscoverySettings by <code>BKClient.discoverySettings</code>
/// Every setting value is writeable and has a default value that is used if not changed by the developer.
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
/// Maximum value for rssi threshold: -20
@property (nonatomic, readonly) NSInteger RSSI_MAX;
/// Minimum value for rssi threshold: -120
@property (nonatomic, readonly) NSInteger RSSI_MIN;
/// Default value for rssi threshold: -85
@property (nonatomic, readonly) NSInteger RSSI_DEFAULT;
/// Gets the rssi threshold for the discovery.
/// BLE modules with a higher rssi value will be discovered only.
///
/// returns:
/// rssi threshold value, default is <code>RSSI_DEFAULT</code>
- (NSInteger)getRssiThreshold SWIFT_WARN_UNUSED_RESULT;
/// Sets the rssi threshold for the discovery.
/// BLE modules with a higher rssi value will be discovered only.
/// The valid range for the rssi threshold is limited by <code>RSSI_MIN</code> and <code>RSSI_MAX</code>
- (void)setRssiThreshold:(NSInteger)rssiThreshold;
/// The state if discovery should calculate the average RSSI of all scanned frames.
/// Otherwise the last found RSSI Value is returned on <code>BKDiscoveryData.getRssi()</code>
/// Default value is true
///
/// returns:
/// true, if Rssi average is calculated
@property (nonatomic) BOOL calculatingRssiAverage;
/// Scan duration of one discovery phase: 2000 milliseconds.
@property (nonatomic, readonly) NSInteger SCANDURATION_DEFAULT;
/// Value of the duration of one discovery phase in milliseconds. Default is <code>SCANDURATION_DEFAULT</code>
/// After the scan duration has finished all scanned BLE data is saved into a list of BKOutputElement and returned by delegate  <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>
@property (nonatomic) NSInteger scanDuration;
/// Scan Wait duration between two discovery phase: 15000 milliseconds
@property (nonatomic, readonly) NSInteger SCANWAITDURATION_DEFAULT;
/// Value of the waiting time between two discovery phase in milliseconds. Default is <code>SCANWAITDURATION_DEFAULT</code>
@property (nonatomic) NSInteger scanWaitDuration;
/// Default Value for disableWaitTimeAtStartForTime
@property (nonatomic, readonly) NSInteger DISABLESCANWAITTIMEATSTARTFORTIME_DEFAULT;
/// Value of the Time in seconds, wich the scanWaitDuration will be disabled, at the start of a scan. Default is <code>DISABLESCANWAITTIMEATSTARTFORTIME_DEFAULT</code>
@property (nonatomic) NSInteger disableScanWaitTimeAtStartForTime;
/// Enables / Disables Background scanning.
/// <em>Background mode</em>: If the app change to the background, the scan will not stop. Conditions:
/// <ul>
///   <li>
///     capabilities -> Background Modes -> Location Update -> enable
///   </li>
///   <li>
///     capabilities -> Background Modes -> Use Bluetooth LE accessoires -> enable
///   </li>
///   <li>
///     info.plist: Enter a value for <code>NSLocationAlwaysUsageDescription</code>
///   </li>
/// </ul>
/// For power saving BLE scan is only in a iBeacon region active (Default-Region: 626c756b-6969-2e63-6f6d-6576656e7473) . If you want to scan an InfoBeacon in Background, you have to configure the blukii smartBeacon in Multimode, so that the blukii smartBeacon send iBeacon an infoBeacon protocol.
@property (nonatomic) BOOL scanInBackground;
/// State if the scan wait duration between two discovery phases is disabled on background. Default value is <code>false</code>
@property (nonatomic) BOOL scanContinuouslyOnBackground;
/// Sate if the scan wait duration between two discovery phases is disabled on foreground. Default value is <code>true</code>
@property (nonatomic) BOOL scanContinuouslyOnForeground;
/// Value, if discovery should scan for non blukii BLE modules.
/// <em>Note:</em> The majority of <code>BKDiscoveryData</code> data is only supported for blukii modules: <code>BKBeaconSensorData</code>, <code>BKInfoData</code> and some value of <code>BKDiscoveryData</code>. <code>BKEddystoneData</code> and <code>BKiBeaconData</code> is also supported for non blukii modules.
/// Default value is false
@property (nonatomic) BOOL scanNonBlukiis;
/// the state if discovery should  scan for basic blukii data like firmware, advertising interval, etc.
/// default is true
@property (nonatomic) BOOL scanBlukiiData;
/// Sets the stat if discovery should scan for sensor data of blukii beacons.
/// If this flag is set <code>BKDiscoveryData</code> may contain a valid <code>BKBeaconSensorData</code> object.
/// <em>Note:</em> This flag is only relevant for blukii beacons
/// Default value is true
@property (nonatomic) BOOL scanBeaconSensorData;
/// Sets the state if discovery should scan for Eddystone data.
/// If this flag is set <code>BKDiscoveryData</code> may contain a valid <code>BKEddystoneData</code> object.
/// Default value is false
@property (nonatomic) BOOL scanEddystoneData;
/// Set the state if discovery should scan for iBeacon data.
/// If this flag is set <code>BKDiscoveryData</code> may contain a valid <code>BKiBeaconData</code> object.
/// <em>Note:</em> For scanning iBeacons in the info.plist it is reuqiered to enter a value for NSLocationAlwaysUsageDescription.
/// Default value is false
@property (nonatomic) BOOL scanIBeaconData;
/// Default Value iBeacon UUID Regions
/// Values:
/// <ul>
///   <li>
///     01234567-89AB-CDEF-0123-000000000001: old blukii Default
///   </li>
///   <li>
///     626c756b-6969-2e63-6f6d-6576656e7473: new blukii Default
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull IBEACONREGIONS_DEFAULT SWIFT_DEPRECATED_MSG("Please use ibeaconRegionsDefault()");
/// Default Value iBeacon UUID Regions
/// Values:
///
/// returns:
/// The default Values for blukii beacons
- (NSArray<CLBeaconRegion *> * _Nonnull)ibeaconRegionsDefault SWIFT_WARN_UNUSED_RESULT;
/// Set the for detection of secureBeacon UUID
/// This UUID must also be  set at <code>setScanIBeaconRegions(regions:)</code> for detection of the secureBeacon
@property (nonatomic, copy) NSUUID * _Nonnull securebeaconUUID;
/// Set the Regions that will be scanned by the Discovery Service.
/// Default Value is IBEACONREGIONS_DEFAULT
/// Note: You can Use the setScanIBeaconRegions(regions: [CLBeaconRegion]) function or this function
/// If both functions are set, the last one is taken.
/// \param regions Array with Region IDs
///
- (void)setScanIBeaconRegionsWithRegionStrings:(NSArray<NSString *> * _Nonnull)regions SWIFT_DEPRECATED_MSG("Please use setScanIBeaconRegions(regions: [CLBeaconRegion])");
/// Get the Regions that will be scanned by the Discovery Service.
///
/// returns:
/// Array with the Region UUID as String
- (NSArray<CLBeaconRegion *> * _Nonnull)getScanIBeaconRegions SWIFT_WARN_UNUSED_RESULT;
/// Set teh Regions that will be scanned by teh Discovery Service
/// Default is <code>ibeaconRegionsDefault()</code>
/// Note: You can Use this function or the function <code>setScanIBeaconRegions(regionStrings:)</code>
/// If both functions are set, the last one is taken.
/// \param regions Array with Region IDs
///
- (void)setScanIBeaconRegionsWithRegions:(NSArray<CLBeaconRegion *> * _Nonnull)regions;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Read only data object for Eddystone data that is emitted by beacons
/// See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
/// <code>BKEddystoneData</code> can contain data of unencrypted EddyStone UID, URL and TLM.
/// <code>BKEddystoneData</code> values are part of <code>BKDiscoveryData</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
/// The UIDNamespace if the beacon is emitting an Eddystone UID
@property (nonatomic, readonly, copy) NSString * _Nullable uidNamespace;
/// The Instance ID if the beacon is emitting an Eddystone UID
@property (nonatomic, readonly, copy) NSString * _Nullable uidInstance;
/// The url string if the beacon is emitting an Eddystone URL
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// The txPower value if the beacon is emitting Eddystone TLM.
/// It stands for the measured RSSI value when the distance between the beacon and the mobile device is 0 meter.
///
/// returns:
/// txPower in dBm, <code>Int16.min</code> if it is not supported
@property (nonatomic, readonly) int16_t txPower;
/// The battery charge value if the Beacon is emitting Eddystone TLM
///
/// returns:
/// Battery charge in mV, 0 if the blukii has USB power, <code>Int.min</code> if it is not supported
@property (nonatomic, readonly) NSInteger battery;
/// The Temperature value if the beacon is emitting Eddystone TLM.
///
/// returns:
/// Temperature in degress Celsius (°C), <code>Float()</code> if it is not supported
@property (nonatomic, readonly) float temperature;
/// the number of frame packets since the last beacon reset if the beacon is emitting Eddystone TLM
///
/// returns:
/// Number of frame packets since last reset, 0 if it is not supported
@property (nonatomic, readonly) NSInteger packets;
/// The Time since the last beacon reset if the beacon is emitting Eddystone TLM
///
/// returns:
/// Number of seconds since last reset, 0 if it is not supported.
@property (nonatomic, readonly) NSInteger activeTime;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Helper class to validate application and mobile device features
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
/// Checks if the App is on foreground
///
/// returns:
/// true if App is on foreground
- (BOOL)isAppOnForeground SWIFT_WARN_UNUSED_RESULT;
/// Checks if the device is connected to the internet.
///
/// returns:
/// true if connected to the internet
- (BOOL)isConnectedToInternet SWIFT_WARN_UNUSED_RESULT;
/// Checks if Bluetooth is enabled on the device
///
/// returns:
/// true if Bluetooth is enabled
- (BOOL)bluetoothIsEnabled SWIFT_WARN_UNUSED_RESULT;
/// Checks if Bluetooth access is allowed
///
/// returns:
/// true if Bluetooth is allowed for the current app
- (BOOL)bluetoothAccessDenied SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoBundleOutputData;

/// Read only data object for Info Bundle data retrieved from blukii Manager Info CMS.
/// It contains the results of the <code>BKBlukiiInfo.getInfoBundles(bundleIds:completionHandler:)</code> request to the blukii Manager Info CMS (https://manager.blukii.com).
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoBundleData")
@interface BKInfoBundleData : NSObject <NSCoding>
/// The Bundle Id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The map of bundle output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> Englisch
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this dictionary only contains ouput data of languages that are configured for the Bundle on blukii Manager CMS.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoBundleOutputData *> * _Nonnull outputDataList;
/// If the InfoData items has been marked as protected.
/// true, if protedted
@property (nonatomic, readonly) BOOL itemsProtected;
/// The timestamp of last retrieve from blukii Manager.
/// timestamp in milliseconds
@property (nonatomic, readonly) int64_t timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
@end


/// Read only data object for output language based info bundle data retrieved from blukii Manager Info CMS.
/// It is a child object of  <code>BKInfoBundleData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo22BKInfoBundleOutputData")
@interface BKInfoBundleOutputData : NSObject <NSCoding>
/// The value of the language specific Title.
/// <em>Note:</em> If the language specific field Title is not set title contains the value of field <code>BKInfoBundleData.name</code> (as fallback).
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The url of the Bundles Preview Image.
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoOutputData;

/// Read only data object for data of BLE discover and resolving process.
/// It contains the results of the <code>BKBlukiiInfo.getInfoData(blukiiIds:completionHandler:)</code> request to the blukii Manager Info CMS(https://manager.blukii.com).
/// The BKInfoData fields contain the values of one corresponding blukii number.
SWIFT_CLASS("_TtC10BlukiiInfo10BKInfoData")
@interface BKInfoData : NSObject <NSSecureCoding>
/// The Info data id.
///
/// returns:
/// id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The blukii Numbers of the Info.
///
/// returns:
/// Blukii Id list
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull blukiiList;
/// The map of Info output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> English
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this map only contains output data of languages that are configured for the Info on blukii Manager CMS.
///
/// returns:
/// map of ouput data
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoOutputData *> * _Nonnull outputDataList;
/// The value of the blukii number field Visibility range.
/// This value contains a Bluetooth module defined value for the rssi range in addition to the global rssi setting (@see <code>BKDiscoverySettings.getRssiThreshold()</code>.
/// It does not affect the BLE scan itself but is designed for a better output handling.
///
/// returns:
/// Value of blukii number field Visibility range
@property (nonatomic, readonly) int64_t rssi;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nullable condition;
/// The identifiable name of the Info data.
///
/// returns:
/// Info Data Name
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// :nodoc:
@property (nonatomic, readonly) NSInteger infoProviderId;
/// The timestamp of last retrieve from blukii Manager.
///
/// returns:
/// Timestamp as <code>Date</code>
@property (nonatomic, readonly, copy) NSDate * _Nonnull timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for output language based blukii data retrieved from blukii Manager Info CMS.
/// It is a child object of <code>BKInfoData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoOutputData")
@interface BKInfoOutputData : NSObject <NSCoding>
/// The value of output <em>Title</em>
///
/// returns:
/// Value of Title
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The value of output <em>URL</em>.
///
/// returns:
/// Value of URL
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// Gets the url of <em>preview Image</em>
///
/// returns:
/// Value of preview url
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
/// The value of the <em>Audio File URL</em>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a url of an audio file.
///
/// returns:
/// Value of Audio File URL of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable urlExtra;
/// The value of  <em>Text to speech</em>.
/// The language is defined by property <code>language</code>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a text.
///
/// returns:
/// Value of Text to speech of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable plainTextExtra;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
@end

enum Mode : NSInteger;

/// Read only data set for blukii SmartKey
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
/// Gets the state if the SmartKey has been time synced since last restart
@property (nonatomic, readonly) BOOL timeSync;
/// Gets the operating mode of the Smart Key that determines the security level
@property (nonatomic, readonly) enum Mode mode;
/// The state if the SmartKey has been pushed.
/// <em>Note:</em> only supported for blukiis with push button
@property (nonatomic, readonly) BOOL isButtonPushed;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

/// Operating mode of the Smart Key that determines the security level
typedef SWIFT_ENUM(NSInteger, Mode, open) {
/// No mode is configured
  ModeOFF = 0,
/// low security level; authentication via BLE device address
  ModeCONVENIENCE = 1,
/// medium security level; authentication via pairing key
  ModePAIRING = 2,
/// MODE_SECURE, pairing key is not yet set
  ModeSECURE_PREPARED = 3,
/// high security level; authentication via AES128 encrypted key and pairing key
  ModeSECURE = 4,
};

/// Indicates if blukii SmartBeacon is sending SecureBeacon advertising and if <code>BKDiscoveryData</code> object contains encrypted data.
typedef SWIFT_ENUM(NSInteger, BKSecureBeaconState, open) {
/// blukii SmartBeacon is not a SecureBeacon
/// To detect this correct, set the correct UUID in <code>BKDiscoverySettings.securebeaconUUID</code>
  BKSecureBeaconStateOff = 0,
/// blukii SmartBeacon is a SecureBeacon. DiscoveryData contains encrypted mac address and iBeacon Major and Minor values.
  BKSecureBeaconStateEncrypted = 1,
/// blukii SmartBeacon is a SecureBeacon. DiscoveryData contains decrypted mac address and iBeacon Major and Minor values.
  BKSecureBeaconStateDecrypted = 2,
};

@class NSNumber;

/// <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
/// See iBeacon specification at https://developer.apple.com/ibeacon
/// iBeaconData values are part of <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/// The UUID if the beacon is emitting iBeacon
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/// The Major ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/// The Minor ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
/// The relative distance to the beacon.
@property (nonatomic, readonly) CLProximity proximity;
/// The accuracy of the proximity value, measured in meters from the beacon.
@property (nonatomic, readonly) CLLocationAccuracy accuracy;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif
